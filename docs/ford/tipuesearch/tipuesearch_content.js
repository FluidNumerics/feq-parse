var tipuesearch = {"pages":[{"title":" FEQParse ","text":"FEQParse Developer Info Fluid Numerics Committed to service for science","tags":"home","loc":"index.html"},{"title":"EquationParser – FEQParse ","text":"type, public :: EquationParser Contents Variables equation inFix inFixFormula indepVars nIndepVars postFix variableName Constructor EquationParser Finalization Procedures Finalize_EquationParser Type-Bound Procedures CleanEquation ConvertToPostfix Evaluate Evaluate_r1fp32 Evaluate_r1fp64 Evaluate_r2fp32 Evaluate_r2fp64 Evaluate_r3fp32 Evaluate_r3fp64 Evaluate_r4fp32 Evaluate_r4fp64 Evaluate_sfp32 Evaluate_sfp64 Print_InFixTokens Print_PostFixTokens Priority Tokenize Source Code EquationParser Components Type Visibility Attributes Name Initial character, public, allocatable :: equation type( TokenStack ), public :: inFix character, public, allocatable :: inFixFormula type( IndepVar ), public, dimension(:), allocatable :: indepVars integer, public :: nIndepVars type( TokenStack ), public :: postFix character, public, allocatable :: variableName Constructor public interface EquationParser private function Construct_EquationParser (equation, indepVars) result(parser) Arguments Type Intent Optional Attributes Name character :: equation character :: indepVars (:) Return Value type( EquationParser ) Finalization Procedures final :: Finalize_EquationParser private subroutine Finalize_EquationParser (parser) Arguments Type Intent Optional Attributes Name type( EquationParser ), intent(inout) :: parser Type-Bound Procedures procedure, public :: CleanEquation private subroutine CleanEquation (parser, equationCleaned) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(inout) :: parser logical, intent(out) :: equationCleaned procedure, public :: ConvertToPostfix => ConvertToPostFix private subroutine ConvertToPostFix (parser) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(inout) :: parser generic, public :: Evaluate => Evaluate_sfp32 , Evaluate_sfp64 , Evaluate_r1fp32 , Evaluate_r1fp64 , Evaluate_r2fp32 , Evaluate_r2fp64 , Evaluate_r3fp32 , Evaluate_r3fp64 , Evaluate_r4fp32 , Evaluate_r4fp64 private function Evaluate_sfp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (1:parser%nIndepVars) Return Value real(kind=real32) private function Evaluate_sfp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (1:parser%nIndepVars) Return Value real(kind=real64) private function Evaluate_r1fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1)) private function Evaluate_r1fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1)) private function Evaluate_r2fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2)) private function Evaluate_r2fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2)) private function Evaluate_r3fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3)) private function Evaluate_r3fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3)) private function Evaluate_r4fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3),lbound(x,4):ubound(x,4)) private function Evaluate_r4fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3),lbound(x,4):ubound(x,4)) procedure, private :: Evaluate_r1fp32 private function Evaluate_r1fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1)) procedure, private :: Evaluate_r1fp64 private function Evaluate_r1fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1)) procedure, private :: Evaluate_r2fp32 private function Evaluate_r2fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2)) procedure, private :: Evaluate_r2fp64 private function Evaluate_r2fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2)) procedure, private :: Evaluate_r3fp32 private function Evaluate_r3fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3)) procedure, private :: Evaluate_r3fp64 private function Evaluate_r3fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3)) procedure, private :: Evaluate_r4fp32 private function Evaluate_r4fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3),lbound(x,4):ubound(x,4)) procedure, private :: Evaluate_r4fp64 private function Evaluate_r4fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3),lbound(x,4):ubound(x,4)) procedure, private :: Evaluate_sfp32 private function Evaluate_sfp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (1:parser%nIndepVars) Return Value real(kind=real32) procedure, private :: Evaluate_sfp64 private function Evaluate_sfp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (1:parser%nIndepVars) Return Value real(kind=real64) procedure, public :: Print_InFixTokens => Print_InfixTokens private subroutine Print_InfixTokens (parser) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(in) :: parser procedure, public :: Print_PostFixTokens => Print_PostfixTokens private subroutine Print_PostfixTokens (parser) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(in) :: parser procedure, private, nopass :: Priority private function Priority (toke) Arguments Type Intent Optional Attributes Name type( Token ) :: toke Return Value integer procedure, public :: Tokenize private subroutine Tokenize (parser, tokenized, errorMsg) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(inout) :: parser logical, intent(out) :: tokenized character, intent(out), allocatable :: errorMsg Source Code type , public :: EquationParser character (:), allocatable :: equation character (:), allocatable :: variableName character (:), allocatable :: inFixFormula integer :: nIndepVars type ( IndepVar ), dimension (:), allocatable :: indepVars type ( TokenStack ) :: inFix type ( TokenStack ) :: postFix contains final :: Finalize_EquationParser procedure :: CleanEquation procedure :: Tokenize procedure :: ConvertToPostfix generic :: Evaluate => Evaluate_sfp32 , Evaluate_sfp64 , & Evaluate_r1fp32 , Evaluate_r1fp64 , & Evaluate_r2fp32 , Evaluate_r2fp64 , & Evaluate_r3fp32 , Evaluate_r3fp64 , & Evaluate_r4fp32 , Evaluate_r4fp64 procedure , private :: Evaluate_sfp32 , Evaluate_sfp64 procedure , private :: Evaluate_r1fp32 , Evaluate_r1fp64 procedure , private :: Evaluate_r2fp32 , Evaluate_r2fp64 procedure , private :: Evaluate_r3fp32 , Evaluate_r3fp64 procedure , private :: Evaluate_r4fp32 , Evaluate_r4fp64 procedure :: Print_InFixTokens procedure :: Print_PostFixTokens procedure , nopass , private :: Priority endtype EquationParser","tags":"","loc":"type/equationparser.html"},{"title":"IndepVar – FEQParse ","text":"type, private :: IndepVar Contents Variables value Components Type Visibility Attributes Name Initial character, private, allocatable :: value","tags":"","loc":"type/indepvar.html"},{"title":"Token – FEQParse ","text":"type, public :: Token Contents Variables tokenIndex tokenString tokenType Type-Bound Procedures Copy Components Type Visibility Attributes Name Initial integer, public :: tokenIndex character(len=48), public :: tokenString integer, public :: tokenType Type-Bound Procedures procedure, public :: Copy public function Copy (this) result(that) Arguments Type Intent Optional Attributes Name class( Token ) :: this Return Value type( Token )","tags":"","loc":"type/token.html"},{"title":"TokenStack – FEQParse ","text":"type, public :: TokenStack Contents Variables tokens top_index Type-Bound Procedures Construct Finalize IsEmpty Pop Push TopToken Components Type Visibility Attributes Name Initial type( Token ), public, allocatable :: tokens (:) integer, public :: top_index = 0 Type-Bound Procedures procedure, public :: Construct => Construct_TokenStack public subroutine Construct_TokenStack (stack, N) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(out) :: stack integer, intent(in) :: N procedure, public :: Finalize => Finalize_TokenStack public subroutine Finalize_TokenStack (stack) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(inout) :: stack procedure, public :: IsEmpty => IsEmpty_TokenStack public function IsEmpty_TokenStack (stack) Arguments Type Intent Optional Attributes Name class( TokenStack ) :: stack Return Value logical procedure, public :: Pop => Pop_TokenStack public subroutine Pop_TokenStack (stack, tok) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(inout) :: stack type( Token ), intent(out) :: tok procedure, public :: Push => Push_TokenStack public subroutine Push_TokenStack (stack, tok) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(inout) :: stack type( Token ), intent(in) :: tok procedure, public :: TopToken public function TopToken (stack) Arguments Type Intent Optional Attributes Name class( TokenStack ) :: stack Return Value type( Token )","tags":"","loc":"type/tokenstack.html"},{"title":"FEQParse_Function – FEQParse ","text":"type, public :: FEQParse_Function Contents Variables caps len ptr32 ptr64 str Finalization Procedures Function_Finalize Type-Bound Procedures assignment(=) character_array_assign_function character_assign_function character_eq_function character_neq_function function_eq_character function_neq_character invoke invoke32 invoke64 operator(/=) operator(==) Source Code FEQParse_Function Components Type Visibility Attributes Name Initial character, public, allocatable :: caps integer, public :: len procedure( f32 ), public, nopass, pointer :: ptr32 => null() procedure( f64 ), public, nopass, pointer :: ptr64 => null() character, public, allocatable :: str Finalization Procedures final :: Function_Finalize private subroutine Function_Finalize (this) Arguments Type Intent Optional Attributes Name type( FEQParse_Function ), intent(inout) :: this Type-Bound Procedures generic, public :: assignment(=) => character_assign_function , character_array_assign_function private subroutine character_assign_function (lhs, rhs) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(inout) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. private subroutine character_array_assign_function (lhs, rhs) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(inout) :: lhs Left hand side. class( Tuple ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: character_array_assign_function private subroutine character_array_assign_function (lhs, rhs) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(inout) :: lhs Left hand side. class( Tuple ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: character_assign_function private subroutine character_assign_function (lhs, rhs) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(inout) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. procedure, private, pass(rhs) :: character_eq_function private elemental function character_eq_function (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs class( FEQParse_Function ), intent(in) :: rhs Return Value logical procedure, private, pass(rhs) :: character_neq_function private elemental function character_neq_function (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs class( FEQParse_Function ), intent(in) :: rhs Return Value logical procedure, private, pass(lhs) :: function_eq_character private elemental function function_eq_character (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value logical procedure, private, pass(lhs) :: function_neq_character private elemental function function_neq_character (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value logical generic, public :: invoke => invoke32 , invoke64 private elemental function invoke32 (this, x) result(fx) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: this real(kind=real32), intent(in) :: x Return Value real(kind=real32) private elemental function invoke64 (this, x) result(fx) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: this real(kind=real64), intent(in) :: x Return Value real(kind=real64) procedure, private, pass(this) :: invoke32 private elemental function invoke32 (this, x) result(fx) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: this real(kind=real32), intent(in) :: x Return Value real(kind=real32) procedure, private, pass(this) :: invoke64 private elemental function invoke64 (this, x) result(fx) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: this real(kind=real64), intent(in) :: x Return Value real(kind=real64) generic, public :: operator(/=) => function_neq_character , character_neq_function private elemental function function_neq_character (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value logical private elemental function character_neq_function (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs class( FEQParse_Function ), intent(in) :: rhs Return Value logical generic, public :: operator(==) => function_eq_character , character_eq_function private elemental function function_eq_character (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value logical private elemental function character_eq_function (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs class( FEQParse_Function ), intent(in) :: rhs Return Value logical Source Code type , public :: FEQParse_Function integer :: len character (:), allocatable :: str character (:), allocatable :: caps procedure ( f32 ), public , nopass , pointer :: ptr32 => null () procedure ( f64 ), public , nopass , pointer :: ptr64 => null () contains procedure , private , pass ( lhs ) :: character_array_assign_function procedure , private , pass ( lhs ) :: character_assign_function generic :: assignment ( = ) => character_assign_function , character_array_assign_function procedure , private , pass ( lhs ) :: function_eq_character procedure , private , pass ( rhs ) :: character_eq_function generic :: operator ( == ) => function_eq_character , character_eq_function procedure , private , pass ( lhs ) :: function_neq_character procedure , private , pass ( rhs ) :: character_neq_function generic :: operator ( /= ) => function_neq_character , character_neq_function procedure , private , pass ( this ) :: invoke32 procedure , private , pass ( this ) :: invoke64 generic :: invoke => invoke32 , invoke64 final :: Function_Finalize endtype FEQParse_Function","tags":"","loc":"type/feqparse_function.html"},{"title":"Tuple – FEQParse ","text":"type, public :: Tuple Contents Variables item1 item2 Constructor Tuple Finalization Procedures Tuple_Finalize Components Type Visibility Attributes Name Initial character, private, allocatable :: item1 character, private, allocatable :: item2 Constructor public interface Tuple private function Tuple_new (item1, item2) result(t) Arguments Type Intent Optional Attributes Name character, intent(in) :: item1 character, intent(in) :: item2 Return Value type( Tuple ) Finalization Procedures final :: Tuple_Finalize private subroutine Tuple_Finalize (this) Arguments Type Intent Optional Attributes Name type( Tuple ), intent(inout) :: this","tags":"","loc":"type/tuple.html"},{"title":"feqparse_floatstack – FEQParse ","text":"type, public :: feqparse_floatstack Contents Variables top_index Source Code feqparse_floatstack Components Type Visibility Attributes Name Initial integer, public :: top_index Source Code type feqparse_floatstack integer :: top_index endtype feqparse_floatstack","tags":"","loc":"type/feqparse_floatstack.html"},{"title":"r1fp32Stack – FEQParse ","text":"type, public, extends( feqparse_floatstack ) :: r1fp32Stack Contents Variables tokens top_index Finalization Procedures Finalize_r1fp32Stack Type-Bound Procedures Construct Pop Push Source Code r1fp32Stack Components Type Visibility Attributes Name Initial real(kind=real32), public, allocatable :: tokens (:,:) integer, public :: top_index Finalization Procedures final :: Finalize_r1fp32Stack public subroutine Finalize_r1fp32Stack (stack) Arguments Type Intent Optional Attributes Name type( r1fp32Stack ), intent(inout) :: stack Type-Bound Procedures procedure, public :: Construct => Construct_r1fp32Stack public subroutine Construct_r1fp32Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r1fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:) procedure, public :: Pop => Pop_r1fp32Stack public subroutine Pop_r1fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:) procedure, public :: Push => Push_r1fp32Stack public subroutine Push_r1fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:) Source Code type , extends ( feqparse_floatstack ) :: r1fp32Stack real ( real32 ), allocatable :: tokens (:,:) contains procedure :: Construct => Construct_r1fp32Stack final :: Finalize_r1fp32Stack procedure :: Push => Push_r1fp32Stack procedure :: Pop => Pop_r1fp32Stack endtype r1fp32Stack","tags":"","loc":"type/r1fp32stack.html"},{"title":"r1fp64Stack – FEQParse ","text":"type, public, extends( feqparse_floatstack ) :: r1fp64Stack Contents Variables tokens top_index Finalization Procedures Finalize_r1fp64Stack Type-Bound Procedures Construct Pop Push Source Code r1fp64Stack Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: tokens (:,:) integer, public :: top_index Finalization Procedures final :: Finalize_r1fp64Stack public subroutine Finalize_r1fp64Stack (stack) Arguments Type Intent Optional Attributes Name type( r1fp64Stack ), intent(inout) :: stack Type-Bound Procedures procedure, public :: Construct => Construct_r1fp64Stack public subroutine Construct_r1fp64Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r1fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:) procedure, public :: Pop => Pop_r1fp64Stack public subroutine Pop_r1fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:) procedure, public :: Push => Push_r1fp64Stack public subroutine Push_r1fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:) Source Code type , extends ( feqparse_floatstack ) :: r1fp64Stack real ( real64 ), allocatable :: tokens (:,:) contains procedure :: Construct => Construct_r1fp64Stack final :: Finalize_r1fp64Stack procedure :: Push => Push_r1fp64Stack procedure :: Pop => Pop_r1fp64Stack endtype r1fp64Stack","tags":"","loc":"type/r1fp64stack.html"},{"title":"r2fp32Stack – FEQParse ","text":"type, public, extends( feqparse_floatstack ) :: r2fp32Stack Contents Variables tokens top_index Finalization Procedures Finalize_r2fp32Stack Type-Bound Procedures Construct Pop Push Source Code r2fp32Stack Components Type Visibility Attributes Name Initial real(kind=real32), public, allocatable :: tokens (:,:,:) integer, public :: top_index Finalization Procedures final :: Finalize_r2fp32Stack public subroutine Finalize_r2fp32Stack (stack) Arguments Type Intent Optional Attributes Name type( r2fp32Stack ), intent(inout) :: stack Type-Bound Procedures procedure, public :: Construct => Construct_r2fp32Stack public subroutine Construct_r2fp32Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r2fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:,:) procedure, public :: Pop => Pop_r2fp32Stack public subroutine Pop_r2fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:,:) procedure, public :: Push => Push_r2fp32Stack public subroutine Push_r2fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:,:) Source Code type , extends ( feqparse_floatstack ) :: r2fp32Stack real ( real32 ), allocatable :: tokens (:,:,:) contains procedure :: Construct => Construct_r2fp32Stack final :: Finalize_r2fp32Stack procedure :: Push => Push_r2fp32Stack procedure :: Pop => Pop_r2fp32Stack endtype r2fp32Stack","tags":"","loc":"type/r2fp32stack.html"},{"title":"r2fp64Stack – FEQParse ","text":"type, public, extends( feqparse_floatstack ) :: r2fp64Stack Contents Variables tokens top_index Finalization Procedures Finalize_r2fp64Stack Type-Bound Procedures Construct Pop Push Source Code r2fp64Stack Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: tokens (:,:,:) integer, public :: top_index Finalization Procedures final :: Finalize_r2fp64Stack public subroutine Finalize_r2fp64Stack (stack) Arguments Type Intent Optional Attributes Name type( r2fp64Stack ), intent(inout) :: stack Type-Bound Procedures procedure, public :: Construct => Construct_r2fp64Stack public subroutine Construct_r2fp64Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r2fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:,:) procedure, public :: Pop => Pop_r2fp64Stack public subroutine Pop_r2fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:,:) procedure, public :: Push => Push_r2fp64Stack public subroutine Push_r2fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:,:) Source Code type , extends ( feqparse_floatstack ) :: r2fp64Stack real ( real64 ), allocatable :: tokens (:,:,:) contains procedure :: Construct => Construct_r2fp64Stack final :: Finalize_r2fp64Stack procedure :: Push => Push_r2fp64Stack procedure :: Pop => Pop_r2fp64Stack endtype r2fp64Stack","tags":"","loc":"type/r2fp64stack.html"},{"title":"r3fp32Stack – FEQParse ","text":"type, public, extends( feqparse_floatstack ) :: r3fp32Stack Contents Variables tokens top_index Finalization Procedures Finalize_r3fp32Stack Type-Bound Procedures Construct Pop Push Source Code r3fp32Stack Components Type Visibility Attributes Name Initial real(kind=real32), public, allocatable :: tokens (:,:,:,:) integer, public :: top_index Finalization Procedures final :: Finalize_r3fp32Stack public subroutine Finalize_r3fp32Stack (stack) Arguments Type Intent Optional Attributes Name type( r3fp32Stack ), intent(inout) :: stack Type-Bound Procedures procedure, public :: Construct => Construct_r3fp32Stack public subroutine Construct_r3fp32Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r3fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:,:,:) procedure, public :: Pop => Pop_r3fp32Stack public subroutine Pop_r3fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:,:,:) procedure, public :: Push => Push_r3fp32Stack public subroutine Push_r3fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:,:,:) Source Code type , extends ( feqparse_floatstack ) :: r3fp32Stack real ( real32 ), allocatable :: tokens (:,:,:,:) contains procedure :: Construct => Construct_r3fp32Stack final :: Finalize_r3fp32Stack procedure :: Push => Push_r3fp32Stack procedure :: Pop => Pop_r3fp32Stack endtype r3fp32Stack","tags":"","loc":"type/r3fp32stack.html"},{"title":"r3fp64Stack – FEQParse ","text":"type, public, extends( feqparse_floatstack ) :: r3fp64Stack Contents Variables tokens top_index Finalization Procedures Finalize_r3fp64Stack Type-Bound Procedures Construct Pop Push Source Code r3fp64Stack Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: tokens (:,:,:,:) integer, public :: top_index Finalization Procedures final :: Finalize_r3fp64Stack public subroutine Finalize_r3fp64Stack (stack) Arguments Type Intent Optional Attributes Name type( r3fp64Stack ), intent(inout) :: stack Type-Bound Procedures procedure, public :: Construct => Construct_r3fp64Stack public subroutine Construct_r3fp64Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r3fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:,:,:) procedure, public :: Pop => Pop_r3fp64Stack public subroutine Pop_r3fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:,:,:) procedure, public :: Push => Push_r3fp64Stack public subroutine Push_r3fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:,:,:) Source Code type , extends ( feqparse_floatstack ) :: r3fp64Stack real ( real64 ), allocatable :: tokens (:,:,:,:) contains procedure :: Construct => Construct_r3fp64Stack final :: Finalize_r3fp64Stack procedure :: Push => Push_r3fp64Stack procedure :: Pop => Pop_r3fp64Stack endtype r3fp64Stack","tags":"","loc":"type/r3fp64stack.html"},{"title":"r4fp32Stack – FEQParse ","text":"type, public, extends( feqparse_floatstack ) :: r4fp32Stack Contents Variables tokens top_index Finalization Procedures Finalize_r4fp32Stack Type-Bound Procedures Construct Pop Push Source Code r4fp32Stack Components Type Visibility Attributes Name Initial real(kind=real32), public, allocatable :: tokens (:,:,:,:,:) integer, public :: top_index Finalization Procedures final :: Finalize_r4fp32Stack public subroutine Finalize_r4fp32Stack (stack) Arguments Type Intent Optional Attributes Name type( r4fp32Stack ), intent(inout) :: stack Type-Bound Procedures procedure, public :: Construct => Construct_r4fp32Stack public subroutine Construct_r4fp32Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r4fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:,:,:,:) procedure, public :: Pop => Pop_r4fp32Stack public subroutine Pop_r4fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:,:,:,:) procedure, public :: Push => Push_r4fp32Stack public subroutine Push_r4fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:,:,:,:) Source Code type , extends ( feqparse_floatstack ) :: r4fp32Stack real ( real32 ), allocatable :: tokens (:,:,:,:,:) contains procedure :: Construct => Construct_r4fp32Stack final :: Finalize_r4fp32Stack procedure :: Push => Push_r4fp32Stack procedure :: Pop => Pop_r4fp32Stack endtype r4fp32Stack","tags":"","loc":"type/r4fp32stack.html"},{"title":"r4fp64Stack – FEQParse ","text":"type, public, extends( feqparse_floatstack ) :: r4fp64Stack Contents Variables tokens top_index Finalization Procedures Finalize_r4fp64Stack Type-Bound Procedures Construct Pop Push Source Code r4fp64Stack Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: tokens (:,:,:,:,:) integer, public :: top_index Finalization Procedures final :: Finalize_r4fp64Stack public subroutine Finalize_r4fp64Stack (stack) Arguments Type Intent Optional Attributes Name type( r4fp64Stack ), intent(inout) :: stack Type-Bound Procedures procedure, public :: Construct => Construct_r4fp64Stack public subroutine Construct_r4fp64Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r4fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:,:,:,:) procedure, public :: Pop => Pop_r4fp64Stack public subroutine Pop_r4fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:,:,:,:) procedure, public :: Push => Push_r4fp64Stack public subroutine Push_r4fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:,:,:,:) Source Code type , extends ( feqparse_floatstack ) :: r4fp64Stack real ( real64 ), allocatable :: tokens (:,:,:,:,:) contains procedure :: Construct => Construct_r4fp64Stack final :: Finalize_r4fp64Stack procedure :: Push => Push_r4fp64Stack procedure :: Pop => Pop_r4fp64Stack endtype r4fp64Stack","tags":"","loc":"type/r4fp64stack.html"},{"title":"sfp32Stack – FEQParse ","text":"type, public, extends( feqparse_floatstack ) :: sfp32Stack Contents Variables tokens top_index Finalization Procedures Finalize_sfp32Stack Type-Bound Procedures Construct Pop Push Source Code sfp32Stack Components Type Visibility Attributes Name Initial real(kind=real32), public, allocatable :: tokens (:) integer, public :: top_index Finalization Procedures final :: Finalize_sfp32Stack public subroutine Finalize_sfp32Stack (stack) Arguments Type Intent Optional Attributes Name type( sfp32Stack ), intent(inout) :: stack Type-Bound Procedures procedure, public :: Construct => Construct_sfp32Stack public subroutine Construct_sfp32Stack (stack, N) Arguments Type Intent Optional Attributes Name class( sfp32Stack ), intent(out) :: stack integer, intent(in) :: N procedure, public :: Pop => Pop_sfp32Stack public subroutine Pop_sfp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( sfp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok procedure, public :: Push => Push_sfp32Stack public subroutine Push_sfp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( sfp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok Source Code type , extends ( feqparse_floatstack ) :: sfp32Stack real ( real32 ), allocatable :: tokens (:) contains procedure :: Construct => Construct_sfp32Stack final :: Finalize_sfp32Stack procedure :: Push => Push_sfp32Stack procedure :: Pop => Pop_sfp32Stack endtype sfp32Stack","tags":"","loc":"type/sfp32stack.html"},{"title":"sfp64Stack – FEQParse ","text":"type, public, extends( feqparse_floatstack ) :: sfp64Stack Contents Variables tokens top_index Finalization Procedures Finalize_sfp64Stack Type-Bound Procedures Construct Pop Push Source Code sfp64Stack Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: tokens (:) integer, public :: top_index Finalization Procedures final :: Finalize_sfp64Stack public subroutine Finalize_sfp64Stack (stack) Arguments Type Intent Optional Attributes Name type( sfp64Stack ), intent(inout) :: stack Type-Bound Procedures procedure, public :: Construct => Construct_sfp64Stack public subroutine Construct_sfp64Stack (stack, N) Arguments Type Intent Optional Attributes Name class( sfp64Stack ), intent(out) :: stack integer, intent(in) :: N procedure, public :: Pop => Pop_sfp64Stack public subroutine Pop_sfp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( sfp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok procedure, public :: Push => Push_sfp64Stack public subroutine Push_sfp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( sfp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok Source Code type , extends ( feqparse_floatstack ) :: sfp64Stack real ( real64 ), allocatable :: tokens (:) contains procedure :: Construct => Construct_sfp64Stack final :: Finalize_sfp64Stack procedure :: Push => Push_sfp64Stack procedure :: Pop => Pop_sfp64Stack endtype sfp64Stack","tags":"","loc":"type/sfp64stack.html"},{"title":"randomize_r32 – FEQParse","text":"function randomize_r32() Uses iso_fortran_env Arguments None Return Value real(kind=real32) Contents None","tags":"","loc":"proc/randomize_r32.html"},{"title":"randomize_r64 – FEQParse","text":"function randomize_r64() Uses iso_fortran_env Arguments None Return Value real(kind=real64) Contents None","tags":"","loc":"proc/randomize_r64.html"},{"title":"Construct_EquationParser – FEQParse","text":"private function Construct_EquationParser(equation, indepVars) result(parser) Arguments Type Intent Optional Attributes Name character :: equation character :: indepVars (:) Return Value type( EquationParser ) Contents Source Code Construct_EquationParser Source Code function Construct_EquationParser ( equation , indepVars ) result ( parser ) type ( EquationParser ) :: parser character ( * ) :: equation character ( * ) :: indepVars (:) ! Local integer :: i character (:), allocatable :: errorMsg logical :: equationIsClean , tokenized , success integer :: nIndepVars call InitializeFunctions () nIndepVars = size ( indepVars ) allocate ( parser % indepVars ( 1 : nIndepVars )) parser % nIndepVars = nIndepVars do i = 1 , nIndepVars parser % indepVars ( i )% value = trim ( indepVars ( i )) enddo parser % equation = trim ( equation ) if ( allocated ( parser % inFixFormula )) deallocate ( parser % inFixFormula ) allocate ( character ( len ( parser % equation ) + maxFunctionLength + 1 ) :: parser % inFixFormula ) parser % variableName = '#noname' call parser % CleanEquation ( equationIsClean ) if ( equationIsClean ) then call parser % Tokenize ( tokenized , errorMsg ) if ( tokenized ) then call parser % ConvertToPostFix () else if ( allocated ( errorMsg )) print * , trim ( errorMsg ) success = . false . endif endif endfunction Construct_EquationParser","tags":"","loc":"proc/construct_equationparser.html"},{"title":"Evaluate_r1fp32 – FEQParse","text":"private function Evaluate_r1fp32(parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1)) Contents Source Code Evaluate_r1fp32 Source Code function Evaluate_r1fp32 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real32 ) :: x (:,:) real ( real32 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 )) ! Local integer :: i , k type ( Token ) :: t type ( r1fp32Stack ) :: stack real ( real32 ) :: vnumber real ( real32 ), allocatable :: v (:) real ( real32 ), allocatable :: a (:) real ( real32 ), allocatable :: b (:) real ( real32 ), allocatable :: c (:) allocate ( v ( lbound ( x , 1 ): ubound ( x , 1 )), & a ( lbound ( x , 1 ): ubound ( x , 1 )), & b ( lbound ( x , 1 ): ubound ( x , 1 )), & c ( lbound ( x , 1 ): ubound ( x , 1 ))) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real32 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r1fp32","tags":"","loc":"proc/evaluate_r1fp32.html"},{"title":"Evaluate_r1fp64 – FEQParse","text":"private function Evaluate_r1fp64(parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1)) Contents Source Code Evaluate_r1fp64 Source Code function Evaluate_r1fp64 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real64 ) :: x (:,:) real ( real64 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 )) ! Local integer :: i , k type ( Token ) :: t type ( r1fp64Stack ) :: stack real ( real64 ) :: vnumber real ( real64 ), allocatable :: v (:) real ( real64 ), allocatable :: a (:) real ( real64 ), allocatable :: b (:) real ( real64 ), allocatable :: c (:) allocate ( v ( lbound ( x , 1 ): ubound ( x , 1 )), & a ( lbound ( x , 1 ): ubound ( x , 1 )), & b ( lbound ( x , 1 ): ubound ( x , 1 )), & c ( lbound ( x , 1 ): ubound ( x , 1 ))) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real64 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r1fp64","tags":"","loc":"proc/evaluate_r1fp64.html"},{"title":"Evaluate_r2fp32 – FEQParse","text":"private function Evaluate_r2fp32(parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2)) Contents Source Code Evaluate_r2fp32 Source Code function Evaluate_r2fp32 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real32 ) :: x (:,:,:) real ( real32 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 )) ! Local integer :: i , k type ( Token ) :: t type ( r2fp32Stack ) :: stack real ( real32 ) :: vnumber real ( real32 ), allocatable :: v (:,:) real ( real32 ), allocatable :: a (:,:) real ( real32 ), allocatable :: b (:,:) real ( real32 ), allocatable :: c (:,:) integer :: l1 , l2 , u1 , u2 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) allocate ( v ( l1 : u1 , l2 : u2 ), & a ( l1 : u1 , l2 : u2 ), & b ( l1 : u1 , l2 : u2 ), & c ( l1 : u1 , l2 : u2 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () print * , trim ( t % tokenString ) select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real32 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r2fp32","tags":"","loc":"proc/evaluate_r2fp32.html"},{"title":"Evaluate_r2fp64 – FEQParse","text":"private function Evaluate_r2fp64(parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2)) Contents Source Code Evaluate_r2fp64 Source Code function Evaluate_r2fp64 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real64 ) :: x (:,:,:) real ( real64 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 )) ! Local integer :: i , k type ( Token ) :: t type ( r2fp64Stack ) :: stack real ( real64 ) :: vnumber real ( real64 ), allocatable :: v (:,:) real ( real64 ), allocatable :: a (:,:) real ( real64 ), allocatable :: b (:,:) real ( real64 ), allocatable :: c (:,:) integer :: l1 , l2 , u1 , u2 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) allocate ( v ( l1 : u1 , l2 : u2 ), & a ( l1 : u1 , l2 : u2 ), & b ( l1 : u1 , l2 : u2 ), & c ( l1 : u1 , l2 : u2 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real64 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r2fp64","tags":"","loc":"proc/evaluate_r2fp64.html"},{"title":"Evaluate_r3fp32 – FEQParse","text":"private function Evaluate_r3fp32(parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3)) Contents Source Code Evaluate_r3fp32 Source Code function Evaluate_r3fp32 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real32 ) :: x (:,:,:,:) real ( real32 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 ), & lbound ( x , 3 ): ubound ( x , 3 )) ! Local integer :: i , k type ( Token ) :: t type ( r3fp32Stack ) :: stack real ( real32 ) :: vnumber real ( real32 ), allocatable :: v (:,:,:) real ( real32 ), allocatable :: a (:,:,:) real ( real32 ), allocatable :: b (:,:,:) real ( real32 ), allocatable :: c (:,:,:) integer :: l1 , l2 , l3 , u1 , u2 , u3 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) l3 = lbound ( x , 3 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) u3 = ubound ( x , 3 ) allocate ( v ( l1 : u1 , l2 : u2 , l3 : u3 ), & a ( l1 : u1 , l2 : u2 , l3 : u3 ), & b ( l1 : u1 , l2 : u2 , l3 : u3 ), & c ( l1 : u1 , l2 : u2 , l3 : u3 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real32 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r3fp32","tags":"","loc":"proc/evaluate_r3fp32.html"},{"title":"Evaluate_r3fp64 – FEQParse","text":"private function Evaluate_r3fp64(parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3)) Contents Source Code Evaluate_r3fp64 Source Code function Evaluate_r3fp64 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real64 ) :: x (:,:,:,:) real ( real64 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 ), & lbound ( x , 3 ): ubound ( x , 3 )) ! Local integer :: i , k type ( Token ) :: t type ( r3fp64Stack ) :: stack real ( real64 ) :: vnumber real ( real64 ), allocatable :: v (:,:,:) real ( real64 ), allocatable :: a (:,:,:) real ( real64 ), allocatable :: b (:,:,:) real ( real64 ), allocatable :: c (:,:,:) integer :: l1 , l2 , l3 , u1 , u2 , u3 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) l3 = lbound ( x , 3 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) u3 = ubound ( x , 3 ) allocate ( v ( l1 : u1 , l2 : u2 , l3 : u3 ), & a ( l1 : u1 , l2 : u2 , l3 : u3 ), & b ( l1 : u1 , l2 : u2 , l3 : u3 ), & c ( l1 : u1 , l2 : u2 , l3 : u3 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real64 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r3fp64","tags":"","loc":"proc/evaluate_r3fp64.html"},{"title":"Evaluate_r4fp32 – FEQParse","text":"private function Evaluate_r4fp32(parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3),lbound(x,4):ubound(x,4)) Contents Source Code Evaluate_r4fp32 Source Code function Evaluate_r4fp32 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real32 ) :: x (:,:,:,:,:) real ( real32 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 ), & lbound ( x , 3 ): ubound ( x , 3 ), & lbound ( x , 4 ): ubound ( x , 4 )) ! Local integer :: i , k type ( Token ) :: t type ( r4fp32Stack ) :: stack real ( real32 ) :: vnumber real ( real32 ), allocatable :: v (:,:,:,:) real ( real32 ), allocatable :: a (:,:,:,:) real ( real32 ), allocatable :: b (:,:,:,:) real ( real32 ), allocatable :: c (:,:,:,:) integer :: l1 , l2 , l3 , l4 , u1 , u2 , u3 , u4 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) l3 = lbound ( x , 3 ) l4 = lbound ( x , 3 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) u3 = ubound ( x , 3 ) u4 = ubound ( x , 4 ) allocate ( v ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & a ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & b ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & c ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real32 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:,:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r4fp32","tags":"","loc":"proc/evaluate_r4fp32.html"},{"title":"Evaluate_r4fp64 – FEQParse","text":"private function Evaluate_r4fp64(parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3),lbound(x,4):ubound(x,4)) Contents Source Code Evaluate_r4fp64 Source Code function Evaluate_r4fp64 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real64 ) :: x (:,:,:,:,:) real ( real64 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 ), & lbound ( x , 3 ): ubound ( x , 3 ), & lbound ( x , 4 ): ubound ( x , 4 )) ! Local integer :: i , k type ( Token ) :: t type ( r4fp64Stack ) :: stack real ( real64 ) :: vnumber real ( real64 ), allocatable :: v (:,:,:,:) real ( real64 ), allocatable :: a (:,:,:,:) real ( real64 ), allocatable :: b (:,:,:,:) real ( real64 ), allocatable :: c (:,:,:,:) integer :: l1 , l2 , l3 , l4 , u1 , u2 , u3 , u4 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) l3 = lbound ( x , 3 ) l4 = lbound ( x , 3 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) u3 = ubound ( x , 3 ) u4 = ubound ( x , 4 ) allocate ( v ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & a ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & b ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & c ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real64 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:,:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r4fp64","tags":"","loc":"proc/evaluate_r4fp64.html"},{"title":"Evaluate_sfp32 – FEQParse","text":"private function Evaluate_sfp32(parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (1:parser%nIndepVars) Return Value real(kind=real32) Contents Source Code Evaluate_sfp32 Source Code function Evaluate_sfp32 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real32 ) :: x ( 1 : parser % nIndepVars ) real ( real32 ) :: f ! Local integer :: i , k type ( Token ) :: t type ( sfp32Stack ) :: stack real ( real32 ) :: v , a , b , c call stack % Construct ( Stack_Length ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real32 else read ( t % tokenString , * ) v endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x ( i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a endfunction Evaluate_sfp32","tags":"","loc":"proc/evaluate_sfp32.html"},{"title":"Evaluate_sfp64 – FEQParse","text":"private function Evaluate_sfp64(parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (1:parser%nIndepVars) Return Value real(kind=real64) Contents Source Code Evaluate_sfp64 Source Code function Evaluate_sfp64 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real64 ) :: x ( 1 : parser % nIndepVars ) real ( real64 ) :: f ! Local integer :: i , k type ( Token ) :: t type ( sfp64Stack ) :: stack real ( real64 ) :: v , a , b , c call stack % Construct ( Stack_Length ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real64 else read ( t % tokenString , * ) v endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x ( i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a endfunction Evaluate_sfp64","tags":"","loc":"proc/evaluate_sfp64.html"},{"title":"IsFunction – FEQParse","text":"private function IsFunction(varlen, eqChar, idx) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: varlen character, intent(in) :: eqChar integer, intent(out) :: idx Return Value logical Contents None","tags":"","loc":"proc/isfunction.html"},{"title":"IsNumber – FEQParse","text":"private function IsNumber(eqChar) Arguments Type Intent Optional Attributes Name character(len=1) :: eqChar Return Value logical Contents Source Code IsNumber Source Code logical function IsNumber ( eqChar ) character ( 1 ) :: eqChar ! Local integer :: i IsNumber = . false . if ( eqChar == '.' . or . eqChar == 'p' . or . eqChar == 'P' ) then IsNumber = . true . return endif do i = 1 , 10 if ( eqChar == numbers ( i )) then IsNumber = . true . return endif enddo endfunction IsNumber","tags":"","loc":"proc/isnumber.html"},{"title":"IsOperator – FEQParse","text":"private function IsOperator(eqChar) Arguments Type Intent Optional Attributes Name character(len=1) :: eqChar Return Value logical Contents Source Code IsOperator Source Code logical function IsOperator ( eqChar ) character ( 1 ) :: eqChar ! Local integer :: i IsOperator = . false . do i = 1 , 5 if ( eqChar == operators ( i )) then IsOperator = . true . return endif enddo endfunction IsOperator","tags":"","loc":"proc/isoperator.html"},{"title":"IsSeparator – FEQParse","text":"private function IsSeparator(eqChar) Arguments Type Intent Optional Attributes Name character(len=1) :: eqChar Return Value logical Contents Source Code IsSeparator Source Code logical function IsSeparator ( eqChar ) character ( 1 ) :: eqChar ! Local integer :: i IsSeparator = . false . do i = 1 , nSeparators if ( eqChar == separators ( i )) then IsSeparator = . true . endif enddo endfunction IsSeparator","tags":"","loc":"proc/isseparator.html"},{"title":"IsVariable – FEQParse","text":"private function IsVariable(varlen, eqChar, variables, nvariables) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: varlen character, intent(in) :: eqChar type( IndepVar ) :: variables (1:nvariables) integer :: nvariables Return Value logical Contents Source Code IsVariable Source Code logical function IsVariable ( varlen , eqChar , variables , nvariables ) integer , intent ( inout ) :: varlen character ( * ), intent ( in ) :: eqChar integer :: nvariables type ( IndepVar ) :: variables ( 1 : nvariables ) ! Local integer :: i IsVariable = . false . varlen = 0 if ( any ( separators (:) == eqChar ( 1 : 1 ))) return if ( verify ( eqChar ( 1 : 1 ), '0123456789' ) == 0 ) return do i = 1 , nvariables if ( index ( eqChar , variables ( i )% value ) == 1 ) then IsVariable = . true . if ( len ( variables ( i )% value ) > varlen ) then varlen = len ( variables ( i )% value ) endif endif enddo endfunction IsVariable","tags":"","loc":"proc/isvariable.html"},{"title":"Priority – FEQParse","text":"private function Priority(toke) Arguments Type Intent Optional Attributes Name type( Token ) :: toke Return Value integer Contents Source Code Priority Source Code integer function Priority ( toke ) type ( Token ) :: toke if ( toke % tokenType == Function_Token ) then Priority = 5 elseif ( toke % tokenType == Operator_Token ) then if ( toke % tokenString ( 1 : 1 ) == '&#94;' ) then Priority = 4 elseif ( toke % tokenString ( 1 : 1 ) == '/' ) then Priority = 3 elseif ( toke % tokenString ( 1 : 1 ) == '*' ) then Priority = 2 elseif ( toke % tokenString ( 1 : 1 ) == '+' . or . toke % tokenString ( 1 : 1 ) == '-' ) then Priority = 1 else Priority = 0 endif elseif ( toke % tokenType == Monadic_Token ) then Priority = 5 else Priority = 0 endif endfunction Priority","tags":"","loc":"proc/priority.html"},{"title":"ReplaceStr – FEQParse","text":"private pure recursive function ReplaceStr(string, search, substitute) result(modifiedString) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: search character, intent(in) :: substitute Return Value character,allocatable Contents Source Code ReplaceStr Source Code pure recursive function ReplaceStr ( string , search , substitute ) result ( modifiedString ) implicit none character ( * ), intent ( in ) :: string , search , substitute character (:), allocatable :: modifiedString integer :: i , stringLen , searchLen stringLen = len ( string ) searchLen = len ( search ) if ( stringLen == 0 . or . searchLen == 0 ) then modifiedString = '' return elseif ( stringLen < searchLen ) then modifiedString = string return endif i = 1 do if ( string ( i : i + searchLen - 1 ) == search ) then modifiedString = string ( 1 : i - 1 ) // substitute // replaceStr ( string ( i + searchLen : stringLen ), search , substitute ) exit endif if ( i + searchLen > stringLen ) then modifiedString = string exit endif i = i + 1 cycle enddo endfunction ReplaceStr","tags":"","loc":"proc/replacestr.html"},{"title":"CleanEquation – FEQParse","text":"private subroutine CleanEquation(parser, equationCleaned) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(inout) :: parser logical, intent(out) :: equationCleaned Contents Source Code CleanEquation Source Code subroutine CleanEquation ( parser , equationCleaned ) class ( EquationParser ), intent ( inout ) :: parser logical , intent ( out ) :: equationCleaned ! Local integer :: nChar , equalSignLoc , j , i , n character (:), allocatable :: infixformula equationCleaned = . false . equalSignLoc = index ( parser % equation , '=' ) if ( equalSignLoc /= 0 ) then parser % variableName = parser % equation ( 1 : equalSignLoc - 1 ) endif !Replace ** for &#94; parser % equation = ReplaceStr ( parser % equation , '**' , '&#94;' ) nChar = len_trim ( parser % equation ) ! Grab the formula to the right of the equal sign and left adjust the formula inFixFormula = parser % equation ( equalSignLoc + 1 :) ! Remove any spaces j = 1 n = len ( inFixFormula ) do i = 1 , n if ( inFixFormula ( i : i ) /= ' ' ) then parser % inFixFormula ( j : j ) = inFixFormula ( i : i ) j = j + 1 endif enddo parser % inFixFormula ( j :) = ' ' equationCleaned = . true . endsubroutine CleanEquation","tags":"","loc":"proc/cleanequation.html"},{"title":"ConvertToPostFix – FEQParse","text":"private subroutine ConvertToPostFix(parser) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(inout) :: parser Contents Source Code ConvertToPostFix Source Code subroutine ConvertToPostFix ( parser ) class ( EquationParser ), intent ( inout ) :: parser ! Local type ( TokenStack ) :: operator_stack type ( Token ) :: tok integer :: i call parser % postfix % Construct ( Stack_Length ) call operator_stack % Construct ( Stack_Length ) do i = 1 , parser % infix % top_index if ( parser % inFix % tokens ( i )% tokenType == Variable_Token . or . & parser % inFix % tokens ( i )% tokenType == Number_Token ) then call parser % postFix % push ( parser % inFix % tokens ( i )) elseif ( parser % inFix % tokens ( i )% tokenType == Function_Token ) then call operator_stack % push ( parser % inFix % tokens ( i )) elseif ( parser % inFix % tokens ( i )% tokenType == Operator_Token & . or . parser % inFix % tokens ( i )% tokenType == Monadic_Token ) then if (. not . operator_stack % IsEmpty ()) then tok = operator_stack % TopToken () do while ( trim ( tok % tokenString ) /= '(' . and . & parser % Priority ( tok ) > & parser % Priority ( parser % inFix % tokens ( i )) . and . & . not . operator_stack % IsEmpty ()) call parser % postFix % push ( tok ) call operator_stack % pop ( tok ) tok = operator_stack % TopToken () enddo endif call operator_stack % push ( parser % inFix % tokens ( i )) elseif ( parser % inFix % tokens ( i )% tokenType == OpeningParentheses_Token ) then call operator_stack % push ( parser % inFix % tokens ( i )) elseif ( parser % inFix % tokens ( i )% tokenType == ClosingParentheses_Token ) then tok = operator_stack % TopToken () do while (. not .( operator_stack % IsEmpty ()) . and . tok % tokenString ( 1 : 1 ) /= '(' ) call parser % postFix % push ( tok ) call operator_stack % pop ( tok ) tok = operator_stack % TopToken () enddo ! Pop the opening parenthesis call operator_stack % pop ( tok ) endif enddo ! Pop the remaining operators do while (. not .( operator_stack % IsEmpty ())) tok = operator_stack % TopToken () call parser % postFix % push ( tok ) call operator_stack % pop ( tok ) enddo endsubroutine ConvertToPostFix","tags":"","loc":"proc/converttopostfix.html"},{"title":"Finalize_EquationParser – FEQParse","text":"private subroutine Finalize_EquationParser(parser) Arguments Type Intent Optional Attributes Name type( EquationParser ), intent(inout) :: parser Contents Source Code Finalize_EquationParser Source Code subroutine Finalize_EquationParser ( parser ) type ( EquationParser ), intent ( inout ) :: parser ! Local integer :: i if ( allocated ( parser % inFixFormula )) deallocate ( parser % inFixFormula ) if ( allocated ( parser % equation )) deallocate ( parser % equation ) if ( allocated ( parser % variableName )) deallocate ( parser % variableName ) if ( allocated ( parser % indepVars )) then do i = 1 , parser % nIndepVars deallocate ( parser % indepVars ( i )% value ) enddo deallocate ( parser % indepVars ) endif call parser % infix % Finalize () call parser % postfix % Finalize () endsubroutine Finalize_EquationParser","tags":"","loc":"proc/finalize_equationparser.html"},{"title":"Print_InfixTokens – FEQParse","text":"private subroutine Print_InfixTokens(parser) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(in) :: parser Contents Source Code Print_InfixTokens Source Code subroutine Print_InfixTokens ( parser ) class ( EquationParser ), intent ( in ) :: parser ! Local integer :: i do i = 1 , parser % inFix % top_index print * , trim ( parser % inFix % tokens ( i )% tokenString ) enddo endsubroutine Print_InfixTokens","tags":"","loc":"proc/print_infixtokens.html"},{"title":"Print_PostfixTokens – FEQParse","text":"private subroutine Print_PostfixTokens(parser) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(in) :: parser Contents Source Code Print_PostfixTokens Source Code subroutine Print_PostfixTokens ( parser ) class ( EquationParser ), intent ( in ) :: parser ! Local integer :: i do i = 1 , parser % postFix % top_index print * , trim ( parser % postFix % tokens ( i )% tokenString ), parser % postFix % tokens ( i )% tokenType enddo endsubroutine Print_PostfixTokens","tags":"","loc":"proc/print_postfixtokens.html"},{"title":"Tokenize – FEQParse","text":"private subroutine Tokenize(parser, tokenized, errorMsg) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(inout) :: parser logical, intent(out) :: tokenized character, intent(out), allocatable :: errorMsg Contents Source Code Tokenize Source Code subroutine Tokenize ( parser , tokenized , errorMsg ) class ( EquationParser ), intent ( inout ) :: parser logical , intent ( out ) :: tokenized character (:), allocatable , intent ( out ) :: errorMsg ! Local integer :: i , j , k , id integer , allocatable :: maxVarLen , varLen tokenized = . false . call parser % infix % Construct ( Stack_Length ) maxVarLen = 0 do k = 1 , parser % nIndepVars maxVarLen = max ( maxVarLen , len ( parser % indepVars ( k )% value )) enddo i = 1 do while ( parser % inFixFormula ( i : i ) /= ' ' ) varLen = maxVarLen if ( IsFunction ( j , parser % infixFormula ( i : i + maxFunctionLength ), id )) then parser % inFix % top_index = parser % inFix % top_index + 1 parser % inFix % tokens ( parser % inFix % top_index )% tokenString = parser % inFixFormula ( i : i + j - 1 ) parser % inFix % tokens ( parser % inFix % top_index )% tokenType = Function_Token parser % inFix % tokens ( parser % inFix % top_index )% tokenIndex = id i = i + j elseif ( IsVariable ( varLen , parser % inFixFormula ( i : i + varLen - 1 ), parser % indepVars , parser % nIndepVars )) then parser % inFix % top_index = parser % inFix % top_index + 1 parser % inFix % tokens ( parser % inFix % top_index )% tokenString = parser % inFixFormula ( i : i + varLen - 1 ) parser % inFix % tokens ( parser % inFix % top_index )% tokenType = Variable_Token i = i + varLen ! Next item must be an operator, closing parentheses, or end of equation if (. not . IsOperator ( parser % infixFormula ( i : i )) . and . & parser % inFixFormula ( i : i ) /= ')' . and . parser % inFixFormula ( i : i ) /= ' ' ) then errorMsg = 'Missing operator or closing parentheses after token : ' // & trim ( parser % inFix % tokens ( parser % inFix % top_index )% tokenString ) return endif elseif ( IsNumber ( parser % inFixFormula ( i : i ))) then parser % inFix % top_index = parser % inFix % top_index + 1 parser % inFix % tokens ( parser % inFix % top_index )% tokenString = '' if ( parser % inFixFormula ( i : i ) == 'p' . or . parser % inFixFormula ( i : i ) == 'P' ) then ! Conditional for using built in 'pi' definition parser % inFix % tokens ( parser % inFix % top_index )% tokenString ( 1 : 2 ) = parser % inFixFormula ( i : i + 1 ) j = 2 else j = 0 do while ( IsNumber ( parser % inFixFormula ( i + j : i + j ))) parser % inFix % tokens ( parser % inFix % top_index )% tokenString ( j + 1 : j + 1 ) = parser % inFixFormula ( i + j : i + j ) j = j + 1 enddo endif parser % inFix % tokens ( parser % inFix % top_index )% tokenType = Number_Token i = i + j ! Next item must be an operator or a closing parentheses if (. not . IsOperator ( parser % infixFormula ( i : i )) . and . & parser % inFixFormula ( i : i ) /= ')' . and . parser % inFixFormula ( i : i ) /= ' ' ) then errorMsg = 'Missing operator or closing parentheses after token : ' // & trim ( parser % inFix % tokens ( parser % inFix % top_index )% tokenString ) return endif elseif ( IsSeparator ( parser % inFixFormula ( i : i ))) then parser % inFix % top_index = parser % inFix % top_index + 1 parser % inFix % tokens ( parser % inFix % top_index )% tokenString = parser % inFixFormula ( i : i ) if ( parser % inFixFormula ( i : i ) == '(' ) then parser % inFix % tokens ( parser % inFix % top_index )% tokenType = OpeningParentheses_Token elseif ( parser % inFixFormula ( i : i ) == ')' ) then parser % inFix % tokens ( parser % inFix % top_index )% tokenType = ClosingParentheses_Token else parser % inFix % tokens ( parser % inFix % top_index )% tokenType = Operator_Token endif i = i + 1 else errorMsg = 'Invalid Token : ' // & trim ( parser % inFixFormula ( i : i )) return endif enddo if ( parser % inFix % tokens ( 1 )% tokenType == Operator_Token ) then if ( trim ( parser % inFix % tokens ( 1 )% tokenString ) == '+' . or . & trim ( parser % inFix % tokens ( 1 )% tokenString ) == '-' ) then parser % inFix % tokens ( 1 )% tokenType = Monadic_Token endif endif do i = 2 , parser % inFix % top_index if ( parser % inFix % tokens ( i )% tokenType == Operator_Token . and . & parser % inFix % tokens ( i - 1 )% tokenType == OpeningParentheses_Token ) then parser % inFix % tokens ( i )% tokenType = Monadic_Token endif enddo tokenized = . true . endsubroutine Tokenize","tags":"","loc":"proc/tokenize.html"},{"title":"EquationParser – FEQParse","text":"public interface EquationParser Contents Module Procedures Construct_EquationParser Module Procedures private function Construct_EquationParser (equation, indepVars) result(parser) Arguments Type Intent Optional Attributes Name character :: equation character :: indepVars (:) Return Value type( EquationParser )","tags":"","loc":"interface/equationparser.html"},{"title":"Copy – FEQParse","text":"public function Copy(this) result(that) Arguments Type Intent Optional Attributes Name class( Token ) :: this Return Value type( Token ) Contents Source Code Copy Source Code function Copy ( this ) result ( that ) class ( Token ) :: this type ( Token ) :: that that % tokenString = this % tokenString that % tokenType = this % tokenType that % tokenIndex = this % tokenIndex endfunction Copy","tags":"","loc":"proc/copy.html"},{"title":"IsEmpty_TokenStack – FEQParse","text":"public function IsEmpty_TokenStack(stack) Arguments Type Intent Optional Attributes Name class( TokenStack ) :: stack Return Value logical Contents Source Code IsEmpty_TokenStack Source Code logical function IsEmpty_TokenStack ( stack ) class ( TokenStack ) :: stack IsEmpty_TokenStack = . false . if ( stack % top_index <= 0 ) then IsEmpty_TokenStack = . true . endif endfunction IsEmpty_TokenStack","tags":"","loc":"proc/isempty_tokenstack.html"},{"title":"TopToken – FEQParse","text":"public function TopToken(stack) Arguments Type Intent Optional Attributes Name class( TokenStack ) :: stack Return Value type( Token ) Contents Source Code TopToken Source Code type ( Token ) function TopToken ( stack ) class ( TokenStack ) :: stack if ( stack % top_index > 0 ) then TopToken % tokenString = stack % tokens ( stack % top_index )% tokenString TopToken % tokenType = stack % tokens ( stack % top_index )% tokenType TopToken % tokenIndex = stack % tokens ( stack % top_index )% tokenIndex else TopToken % tokenString = '' endif endfunction TopToken","tags":"","loc":"proc/toptoken.html"},{"title":"Construct_TokenStack – FEQParse","text":"public subroutine Construct_TokenStack(stack, N) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(out) :: stack integer, intent(in) :: N Contents Source Code Construct_TokenStack Source Code subroutine Construct_TokenStack ( stack , N ) class ( TokenStack ), intent ( out ) :: stack integer , intent ( in ) :: N allocate ( stack % tokens ( 1 : N )) stack % top_index = 0 endsubroutine Construct_TokenStack","tags":"","loc":"proc/construct_tokenstack.html"},{"title":"Finalize_TokenStack – FEQParse","text":"public subroutine Finalize_TokenStack(stack) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(inout) :: stack Contents Source Code Finalize_TokenStack Source Code subroutine Finalize_TokenStack ( stack ) class ( TokenStack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_TokenStack","tags":"","loc":"proc/finalize_tokenstack.html"},{"title":"Pop_TokenStack – FEQParse","text":"public subroutine Pop_TokenStack(stack, tok) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(inout) :: stack type( Token ), intent(out) :: tok Contents Source Code Pop_TokenStack Source Code subroutine Pop_TokenStack ( stack , tok ) class ( TokenStack ), intent ( inout ) :: stack type ( Token ), intent ( out ) :: tok if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok % tokenString = stack % tokens ( stack % top_index )% tokenString tok % tokenType = stack % tokens ( stack % top_index )% tokenType tok % tokenIndex = stack % tokens ( stack % top_index )% tokenIndex stack % top_index = stack % top_index - 1 endif endsubroutine Pop_TokenStack","tags":"","loc":"proc/pop_tokenstack.html"},{"title":"Push_TokenStack – FEQParse","text":"public subroutine Push_TokenStack(stack, tok) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(inout) :: stack type( Token ), intent(in) :: tok Contents Source Code Push_TokenStack Source Code subroutine Push_TokenStack ( stack , tok ) class ( TokenStack ), intent ( inout ) :: stack type ( Token ), intent ( in ) :: tok stack % top_index = stack % top_index + 1 stack % tokens ( stack % top_index )% tokenString = tok % tokenString stack % tokens ( stack % top_index )% tokenType = tok % tokenType stack % tokens ( stack % top_index )% tokenIndex = tok % tokenIndex endsubroutine Push_TokenStack","tags":"","loc":"proc/push_tokenstack.html"},{"title":"ToUpperCase – FEQParse","text":"private pure function ToUpperCase(str) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character Contents Source Code ToUpperCase Source Code pure function ToUpperCase ( str ) result ( res ) character ( * ), intent ( in ) :: str character ( len ( str )) :: res integer :: i do i = 1 , len ( str ) select case ( str ( i : i )) case ( 'a' : 'z' ) res ( i : i ) = achar ( iachar ( str ( i : i )) - 32 ) case default res ( i : i ) = str ( i : i ) endselect enddo endfunction ToUpperCase","tags":"","loc":"proc/touppercase.html"},{"title":"Tuple_new – FEQParse","text":"private function Tuple_new(item1, item2) result(t) Arguments Type Intent Optional Attributes Name character, intent(in) :: item1 character, intent(in) :: item2 Return Value type( Tuple ) Contents None","tags":"","loc":"proc/tuple_new.html"},{"title":"abs32 – FEQParse","text":"private pure function abs32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/abs32.html"},{"title":"abs64 – FEQParse","text":"private pure function abs64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/abs64.html"},{"title":"acos32 – FEQParse","text":"private pure function acos32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/acos32.html"},{"title":"acos64 – FEQParse","text":"private pure function acos64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/acos64.html"},{"title":"asin32 – FEQParse","text":"private pure function asin32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/asin32.html"},{"title":"asin64 – FEQParse","text":"private pure function asin64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/asin64.html"},{"title":"atan32 – FEQParse","text":"private pure function atan32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/atan32.html"},{"title":"atan64 – FEQParse","text":"private pure function atan64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/atan64.html"},{"title":"character_eq_function – FEQParse","text":"private elemental function character_eq_function(lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs class( FEQParse_Function ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/character_eq_function.html"},{"title":"character_neq_function – FEQParse","text":"private elemental function character_neq_function(lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs class( FEQParse_Function ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/character_neq_function.html"},{"title":"cos32 – FEQParse","text":"private pure function cos32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/cos32.html"},{"title":"cos64 – FEQParse","text":"private pure function cos64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/cos64.html"},{"title":"cosh32 – FEQParse","text":"private pure function cosh32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/cosh32.html"},{"title":"cosh64 – FEQParse","text":"private pure function cosh64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/cosh64.html"},{"title":"exp32 – FEQParse","text":"private pure function exp32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/exp32.html"},{"title":"exp64 – FEQParse","text":"private pure function exp64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/exp64.html"},{"title":"function_eq_character – FEQParse","text":"private elemental function function_eq_character(lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value logical Contents None","tags":"","loc":"proc/function_eq_character.html"},{"title":"function_neq_character – FEQParse","text":"private elemental function function_neq_character(lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value logical Contents None","tags":"","loc":"proc/function_neq_character.html"},{"title":"invoke32 – FEQParse","text":"private elemental function invoke32(this, x) result(fx) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: this real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/invoke32.html"},{"title":"invoke64 – FEQParse","text":"private elemental function invoke64(this, x) result(fx) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: this real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/invoke64.html"},{"title":"log1032 – FEQParse","text":"private pure function log1032(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/log1032.html"},{"title":"log1064 – FEQParse","text":"private pure function log1064(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/log1064.html"},{"title":"log32 – FEQParse","text":"private pure function log32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/log32.html"},{"title":"log64 – FEQParse","text":"private pure function log64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/log64.html"},{"title":"rand32 – FEQParse","text":"private pure function rand32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/rand32.html"},{"title":"rand64 – FEQParse","text":"private pure function rand64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/rand64.html"},{"title":"sech32 – FEQParse","text":"private pure function sech32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/sech32.html"},{"title":"sech64 – FEQParse","text":"private pure function sech64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/sech64.html"},{"title":"sin32 – FEQParse","text":"private pure function sin32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/sin32.html"},{"title":"sin64 – FEQParse","text":"private pure function sin64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/sin64.html"},{"title":"sinh32 – FEQParse","text":"private pure function sinh32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/sinh32.html"},{"title":"sinh64 – FEQParse","text":"private pure function sinh64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/sinh64.html"},{"title":"sqrt32 – FEQParse","text":"private pure function sqrt32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/sqrt32.html"},{"title":"sqrt64 – FEQParse","text":"private pure function sqrt64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/sqrt64.html"},{"title":"tan32 – FEQParse","text":"private pure function tan32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/tan32.html"},{"title":"tan64 – FEQParse","text":"private pure function tan64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/tan64.html"},{"title":"tanh32 – FEQParse","text":"private pure function tanh32(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) Contents None","tags":"","loc":"proc/tanh32.html"},{"title":"tanh64 – FEQParse","text":"private pure function tanh64(x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/tanh64.html"},{"title":"AddFunction32 – FEQParse","text":"private subroutine AddFunction32(name, f_32) Arguments Type Intent Optional Attributes Name character, intent(in) :: name procedure( f32 ) :: f_32 Contents None","tags":"","loc":"proc/addfunction32.html"},{"title":"AddFunction64 – FEQParse","text":"private subroutine AddFunction64(name, f_64) Arguments Type Intent Optional Attributes Name character, intent(in) :: name procedure( f64 ) :: f_64 Contents None","tags":"","loc":"proc/addfunction64.html"},{"title":"Function_Finalize – FEQParse","text":"private subroutine Function_Finalize(this) Arguments Type Intent Optional Attributes Name type( FEQParse_Function ), intent(inout) :: this Contents None","tags":"","loc":"proc/function_finalize.html"},{"title":"InitializeFunctions – FEQParse","text":"public subroutine InitializeFunctions() Arguments None Contents Source Code InitializeFunctions Source Code subroutine InitializeFunctions () if ( isInitialized . eqv . . true .) return Functions ( cos_function ) = Tuple ( \"cos\" , \"COS\" ) Functions ( cos_function )% ptr32 => cos32 Functions ( cos_function )% ptr64 => cos64 Functions ( cosh_function ) = Tuple ( \"cosh\" , \"COSH\" ) Functions ( cosh_function )% ptr32 => cosh32 Functions ( cosh_function )% ptr64 => cosh64 Functions ( sin_function ) = Tuple ( \"sin\" , \"SIN\" ) Functions ( sin_function )% ptr32 => sin32 Functions ( sin_function )% ptr64 => sin64 Functions ( sinh_function ) = Tuple ( \"sinh\" , \"SINH\" ) Functions ( sinh_function )% ptr32 => sinh32 Functions ( sinh_function )% ptr64 => sinh64 Functions ( tan_function ) = Tuple ( \"tan\" , \"TAN\" ) Functions ( tan_function )% ptr32 => tan32 Functions ( tan_function )% ptr64 => tan64 Functions ( tanh_function ) = Tuple ( \"tanh\" , \"TANH\" ) Functions ( tanh_function )% ptr32 => tanh32 Functions ( tanh_function )% ptr64 => tanh64 Functions ( sqrt_function ) = Tuple ( \"sqrt\" , \"SQRT\" ) Functions ( sqrt_function )% ptr32 => sqrt32 Functions ( sqrt_function )% ptr64 => sqrt64 Functions ( abs_function ) = Tuple ( \"abs\" , \"ABS\" ) Functions ( abs_function )% ptr32 => abs32 Functions ( abs_function )% ptr64 => abs64 Functions ( exp_function ) = Tuple ( \"exp\" , \"EXP\" ) Functions ( exp_function )% ptr32 => exp32 Functions ( exp_function )% ptr64 => exp64 Functions ( ln_function ) = Tuple ( \"ln\" , \"LN\" ) Functions ( ln_function )% ptr32 => log32 Functions ( ln_function )% ptr64 => log64 Functions ( log_function ) = Tuple ( \"log\" , \"LOG\" ) Functions ( log_function )% ptr32 => log32 Functions ( log_function )% ptr64 => log64 Functions ( log10_function ) = Tuple ( \"log10\" , \"LOG10\" ) Functions ( log10_function )% ptr32 => log1032 Functions ( log10_function )% ptr64 => log1064 Functions ( acos_function ) = Tuple ( \"acos\" , \"ACOS\" ) Functions ( acos_function )% ptr32 => acos32 Functions ( acos_function )% ptr64 => acos64 Functions ( asin_function ) = Tuple ( \"asin\" , \"ASIN\" ) Functions ( asin_function )% ptr32 => asin32 Functions ( asin_function )% ptr64 => asin64 Functions ( atan_function ) = Tuple ( \"atan\" , \"ATAN\" ) Functions ( atan_function )% ptr32 => atan32 Functions ( atan_function )% ptr64 => atan64 Functions ( sech_function ) = Tuple ( \"sech\" , \"SECH\" ) Functions ( sech_function )% ptr32 => sech32 Functions ( sech_function )% ptr64 => sech64 Functions ( rand_function ) = Tuple ( \"rand\" , \"RAND\" ) Functions ( rand_function )% ptr32 => rand32 Functions ( rand_function )% ptr64 => rand64 isInitialized = . true . endsubroutine InitializeFunctions","tags":"","loc":"proc/initializefunctions.html"},{"title":"Tuple_Finalize – FEQParse","text":"private subroutine Tuple_Finalize(this) Arguments Type Intent Optional Attributes Name type( Tuple ), intent(inout) :: this Contents None","tags":"","loc":"proc/tuple_finalize.html"},{"title":"character_array_assign_function – FEQParse","text":"private subroutine character_array_assign_function(lhs, rhs) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(inout) :: lhs Left hand side. class( Tuple ), intent(in) :: rhs Right hand side. Contents None","tags":"","loc":"proc/character_array_assign_function.html"},{"title":"character_assign_function – FEQParse","text":"private subroutine character_assign_function(lhs, rhs) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(inout) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Contents None","tags":"","loc":"proc/character_assign_function.html"},{"title":"AddFunction – FEQParse","text":"public interface AddFunction Contents Module Procedures AddFunction32 AddFunction64 Module Procedures private subroutine AddFunction32 (name, f_32) Arguments Type Intent Optional Attributes Name character, intent(in) :: name procedure( f32 ) :: f_32 private subroutine AddFunction64 (name, f_64) Arguments Type Intent Optional Attributes Name character, intent(in) :: name procedure( f64 ) :: f_64","tags":"","loc":"interface/addfunction.html"},{"title":"Tuple – FEQParse","text":"public interface Tuple Contents Module Procedures Tuple_new Module Procedures private function Tuple_new (item1, item2) result(t) Arguments Type Intent Optional Attributes Name character, intent(in) :: item1 character, intent(in) :: item2 Return Value type( Tuple )","tags":"","loc":"interface/tuple.html"},{"title":"f32 – FEQParse","text":"interface private pure function f32(x) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32)","tags":"","loc":"interface/f32.html"},{"title":"f64 – FEQParse","text":"interface private pure function f64(x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64)","tags":"","loc":"interface/f64.html"},{"title":"randomize_r32 – FEQParse","text":"interface private pure function randomize_r32() Arguments None Return Value real(kind=real32)","tags":"","loc":"interface/randomize_r32.html"},{"title":"randomize_r64 – FEQParse","text":"interface private pure function randomize_r64() Arguments None Return Value real(kind=real64)","tags":"","loc":"interface/randomize_r64.html"},{"title":"Construct_r1fp32Stack – FEQParse","text":"public subroutine Construct_r1fp32Stack(stack, N, mold) Arguments Type Intent Optional Attributes Name class( r1fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:) Contents Source Code Construct_r1fp32Stack Source Code subroutine Construct_r1fp32Stack ( stack , N , mold ) implicit none class ( r1fp32Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real32 ), intent ( in ) :: mold (:) ! local integer :: l ( 1 ) integer :: u ( 1 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), 1 : N )) stack % top_index = 0 endsubroutine Construct_r1fp32Stack","tags":"","loc":"proc/construct_r1fp32stack.html"},{"title":"Construct_r1fp64Stack – FEQParse","text":"public subroutine Construct_r1fp64Stack(stack, N, mold) Arguments Type Intent Optional Attributes Name class( r1fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:) Contents Source Code Construct_r1fp64Stack Source Code subroutine Construct_r1fp64Stack ( stack , N , mold ) class ( r1fp64Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real64 ), intent ( in ) :: mold (:) ! local integer :: l ( 1 ) integer :: u ( 1 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), 1 : N )) stack % top_index = 0 endsubroutine Construct_r1fp64Stack","tags":"","loc":"proc/construct_r1fp64stack.html"},{"title":"Construct_r2fp32Stack – FEQParse","text":"public subroutine Construct_r2fp32Stack(stack, N, mold) Arguments Type Intent Optional Attributes Name class( r2fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:,:) Contents Source Code Construct_r2fp32Stack Source Code subroutine Construct_r2fp32Stack ( stack , N , mold ) class ( r2fp32Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real32 ), intent ( in ) :: mold (:,:) ! local integer :: l ( 1 : 2 ), u ( 1 : 2 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r2fp32Stack","tags":"","loc":"proc/construct_r2fp32stack.html"},{"title":"Construct_r2fp64Stack – FEQParse","text":"public subroutine Construct_r2fp64Stack(stack, N, mold) Arguments Type Intent Optional Attributes Name class( r2fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:,:) Contents Source Code Construct_r2fp64Stack Source Code subroutine Construct_r2fp64Stack ( stack , N , mold ) class ( r2fp64Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real64 ), intent ( in ) :: mold (:,:) ! local integer :: l ( 1 : 2 ), u ( 1 : 2 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r2fp64Stack","tags":"","loc":"proc/construct_r2fp64stack.html"},{"title":"Construct_r3fp32Stack – FEQParse","text":"public subroutine Construct_r3fp32Stack(stack, N, mold) Arguments Type Intent Optional Attributes Name class( r3fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:,:,:) Contents Source Code Construct_r3fp32Stack Source Code subroutine Construct_r3fp32Stack ( stack , N , mold ) class ( r3fp32Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real32 ), intent ( in ) :: mold (:,:,:) ! local integer :: l ( 1 : 3 ), u ( 1 : 3 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & l ( 3 ): u ( 3 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r3fp32Stack","tags":"","loc":"proc/construct_r3fp32stack.html"},{"title":"Construct_r3fp64Stack – FEQParse","text":"public subroutine Construct_r3fp64Stack(stack, N, mold) Arguments Type Intent Optional Attributes Name class( r3fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:,:,:) Contents Source Code Construct_r3fp64Stack Source Code subroutine Construct_r3fp64Stack ( stack , N , mold ) class ( r3fp64Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real64 ), intent ( in ) :: mold (:,:,:) ! local integer :: l ( 1 : 3 ), u ( 1 : 3 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & l ( 3 ): u ( 3 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r3fp64Stack","tags":"","loc":"proc/construct_r3fp64stack.html"},{"title":"Construct_r4fp32Stack – FEQParse","text":"public subroutine Construct_r4fp32Stack(stack, N, mold) Arguments Type Intent Optional Attributes Name class( r4fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:,:,:,:) Contents Source Code Construct_r4fp32Stack Source Code subroutine Construct_r4fp32Stack ( stack , N , mold ) class ( r4fp32Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real32 ), intent ( in ) :: mold (:,:,:,:) ! local integer :: l ( 1 : 4 ), u ( 1 : 4 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & l ( 3 ): u ( 3 ), & l ( 4 ): u ( 4 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r4fp32Stack","tags":"","loc":"proc/construct_r4fp32stack.html"},{"title":"Construct_r4fp64Stack – FEQParse","text":"public subroutine Construct_r4fp64Stack(stack, N, mold) Arguments Type Intent Optional Attributes Name class( r4fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:,:,:,:) Contents Source Code Construct_r4fp64Stack Source Code subroutine Construct_r4fp64Stack ( stack , N , mold ) class ( r4fp64Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real64 ), intent ( in ) :: mold (:,:,:,:) ! local integer :: l ( 1 : 4 ), u ( 1 : 4 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & l ( 3 ): u ( 3 ), & l ( 4 ): u ( 4 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r4fp64Stack","tags":"","loc":"proc/construct_r4fp64stack.html"},{"title":"Construct_sfp32Stack – FEQParse","text":"public subroutine Construct_sfp32Stack(stack, N) Arguments Type Intent Optional Attributes Name class( sfp32Stack ), intent(out) :: stack integer, intent(in) :: N Contents Source Code Construct_sfp32Stack Source Code subroutine Construct_sfp32Stack ( stack , N ) class ( sfp32Stack ), intent ( out ) :: stack integer , intent ( in ) :: N allocate ( stack % tokens ( 1 : N )) stack % top_index = 0 endsubroutine Construct_sfp32Stack","tags":"","loc":"proc/construct_sfp32stack.html"},{"title":"Construct_sfp64Stack – FEQParse","text":"public subroutine Construct_sfp64Stack(stack, N) Arguments Type Intent Optional Attributes Name class( sfp64Stack ), intent(out) :: stack integer, intent(in) :: N Contents Source Code Construct_sfp64Stack Source Code subroutine Construct_sfp64Stack ( stack , N ) class ( sfp64Stack ), intent ( out ) :: stack integer , intent ( in ) :: N allocate ( stack % tokens ( 1 : N )) stack % top_index = 0 endsubroutine Construct_sfp64Stack","tags":"","loc":"proc/construct_sfp64stack.html"},{"title":"Finalize_r1fp32Stack – FEQParse","text":"public subroutine Finalize_r1fp32Stack(stack) Arguments Type Intent Optional Attributes Name type( r1fp32Stack ), intent(inout) :: stack Contents Source Code Finalize_r1fp32Stack Source Code subroutine Finalize_r1fp32Stack ( stack ) type ( r1fp32Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r1fp32Stack","tags":"","loc":"proc/finalize_r1fp32stack.html"},{"title":"Finalize_r1fp64Stack – FEQParse","text":"public subroutine Finalize_r1fp64Stack(stack) Arguments Type Intent Optional Attributes Name type( r1fp64Stack ), intent(inout) :: stack Contents Source Code Finalize_r1fp64Stack Source Code subroutine Finalize_r1fp64Stack ( stack ) type ( r1fp64Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r1fp64Stack","tags":"","loc":"proc/finalize_r1fp64stack.html"},{"title":"Finalize_r2fp32Stack – FEQParse","text":"public subroutine Finalize_r2fp32Stack(stack) Arguments Type Intent Optional Attributes Name type( r2fp32Stack ), intent(inout) :: stack Contents Source Code Finalize_r2fp32Stack Source Code subroutine Finalize_r2fp32Stack ( stack ) type ( r2fp32Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r2fp32Stack","tags":"","loc":"proc/finalize_r2fp32stack.html"},{"title":"Finalize_r2fp64Stack – FEQParse","text":"public subroutine Finalize_r2fp64Stack(stack) Arguments Type Intent Optional Attributes Name type( r2fp64Stack ), intent(inout) :: stack Contents Source Code Finalize_r2fp64Stack Source Code subroutine Finalize_r2fp64Stack ( stack ) type ( r2fp64Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r2fp64Stack","tags":"","loc":"proc/finalize_r2fp64stack.html"},{"title":"Finalize_r3fp32Stack – FEQParse","text":"public subroutine Finalize_r3fp32Stack(stack) Arguments Type Intent Optional Attributes Name type( r3fp32Stack ), intent(inout) :: stack Contents Source Code Finalize_r3fp32Stack Source Code subroutine Finalize_r3fp32Stack ( stack ) type ( r3fp32Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r3fp32Stack","tags":"","loc":"proc/finalize_r3fp32stack.html"},{"title":"Finalize_r3fp64Stack – FEQParse","text":"public subroutine Finalize_r3fp64Stack(stack) Arguments Type Intent Optional Attributes Name type( r3fp64Stack ), intent(inout) :: stack Contents Source Code Finalize_r3fp64Stack Source Code subroutine Finalize_r3fp64Stack ( stack ) type ( r3fp64Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r3fp64Stack","tags":"","loc":"proc/finalize_r3fp64stack.html"},{"title":"Finalize_r4fp32Stack – FEQParse","text":"public subroutine Finalize_r4fp32Stack(stack) Arguments Type Intent Optional Attributes Name type( r4fp32Stack ), intent(inout) :: stack Contents Source Code Finalize_r4fp32Stack Source Code subroutine Finalize_r4fp32Stack ( stack ) type ( r4fp32Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r4fp32Stack","tags":"","loc":"proc/finalize_r4fp32stack.html"},{"title":"Finalize_r4fp64Stack – FEQParse","text":"public subroutine Finalize_r4fp64Stack(stack) Arguments Type Intent Optional Attributes Name type( r4fp64Stack ), intent(inout) :: stack Contents Source Code Finalize_r4fp64Stack Source Code subroutine Finalize_r4fp64Stack ( stack ) type ( r4fp64Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r4fp64Stack","tags":"","loc":"proc/finalize_r4fp64stack.html"},{"title":"Finalize_sfp32Stack – FEQParse","text":"public subroutine Finalize_sfp32Stack(stack) Arguments Type Intent Optional Attributes Name type( sfp32Stack ), intent(inout) :: stack Contents Source Code Finalize_sfp32Stack Source Code subroutine Finalize_sfp32Stack ( stack ) type ( sfp32Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_sfp32Stack","tags":"","loc":"proc/finalize_sfp32stack.html"},{"title":"Finalize_sfp64Stack – FEQParse","text":"public subroutine Finalize_sfp64Stack(stack) Arguments Type Intent Optional Attributes Name type( sfp64Stack ), intent(inout) :: stack Contents Source Code Finalize_sfp64Stack Source Code subroutine Finalize_sfp64Stack ( stack ) type ( sfp64Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_sfp64Stack","tags":"","loc":"proc/finalize_sfp64stack.html"},{"title":"Pop_r1fp32Stack – FEQParse","text":"public subroutine Pop_r1fp32Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:) Contents Source Code Pop_r1fp32Stack Source Code subroutine Pop_r1fp32Stack ( stack , tok ) class ( r1fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( out ) :: tok (:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:) = stack % tokens (:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r1fp32Stack","tags":"","loc":"proc/pop_r1fp32stack.html"},{"title":"Pop_r1fp64Stack – FEQParse","text":"public subroutine Pop_r1fp64Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:) Contents Source Code Pop_r1fp64Stack Source Code subroutine Pop_r1fp64Stack ( stack , tok ) class ( r1fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( out ) :: tok (:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:) = stack % tokens (:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r1fp64Stack","tags":"","loc":"proc/pop_r1fp64stack.html"},{"title":"Pop_r2fp32Stack – FEQParse","text":"public subroutine Pop_r2fp32Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:,:) Contents Source Code Pop_r2fp32Stack Source Code subroutine Pop_r2fp32Stack ( stack , tok ) class ( r2fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( out ) :: tok (:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:) = stack % tokens (:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r2fp32Stack","tags":"","loc":"proc/pop_r2fp32stack.html"},{"title":"Pop_r2fp64Stack – FEQParse","text":"public subroutine Pop_r2fp64Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:,:) Contents Source Code Pop_r2fp64Stack Source Code subroutine Pop_r2fp64Stack ( stack , tok ) class ( r2fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( out ) :: tok (:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:) = stack % tokens (:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r2fp64Stack","tags":"","loc":"proc/pop_r2fp64stack.html"},{"title":"Pop_r3fp32Stack – FEQParse","text":"public subroutine Pop_r3fp32Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:,:,:) Contents Source Code Pop_r3fp32Stack Source Code subroutine Pop_r3fp32Stack ( stack , tok ) class ( r3fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( out ) :: tok (:,:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:,:) = stack % tokens (:,:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r3fp32Stack","tags":"","loc":"proc/pop_r3fp32stack.html"},{"title":"Pop_r3fp64Stack – FEQParse","text":"public subroutine Pop_r3fp64Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:,:,:) Contents Source Code Pop_r3fp64Stack Source Code subroutine Pop_r3fp64Stack ( stack , tok ) class ( r3fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( out ) :: tok (:,:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:,:) = stack % tokens (:,:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r3fp64Stack","tags":"","loc":"proc/pop_r3fp64stack.html"},{"title":"Pop_r4fp32Stack – FEQParse","text":"public subroutine Pop_r4fp32Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:,:,:,:) Contents Source Code Pop_r4fp32Stack Source Code subroutine Pop_r4fp32Stack ( stack , tok ) class ( r4fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( out ) :: tok (:,:,:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:,:,:) = stack % tokens (:,:,:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r4fp32Stack","tags":"","loc":"proc/pop_r4fp32stack.html"},{"title":"Pop_r4fp64Stack – FEQParse","text":"public subroutine Pop_r4fp64Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:,:,:,:) Contents Source Code Pop_r4fp64Stack Source Code subroutine Pop_r4fp64Stack ( stack , tok ) class ( r4fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( out ) :: tok (:,:,:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:,:,:) = stack % tokens (:,:,:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r4fp64Stack","tags":"","loc":"proc/pop_r4fp64stack.html"},{"title":"Pop_sfp32Stack – FEQParse","text":"public subroutine Pop_sfp32Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( sfp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok Contents Source Code Pop_sfp32Stack Source Code subroutine Pop_sfp32Stack ( stack , tok ) class ( sfp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( out ) :: tok if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok = stack % tokens ( stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_sfp32Stack","tags":"","loc":"proc/pop_sfp32stack.html"},{"title":"Pop_sfp64Stack – FEQParse","text":"public subroutine Pop_sfp64Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( sfp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok Contents Source Code Pop_sfp64Stack Source Code subroutine Pop_sfp64Stack ( stack , tok ) class ( sfp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( out ) :: tok if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok = stack % tokens ( stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_sfp64Stack","tags":"","loc":"proc/pop_sfp64stack.html"},{"title":"Push_r1fp32Stack – FEQParse","text":"public subroutine Push_r1fp32Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:) Contents Source Code Push_r1fp32Stack Source Code subroutine Push_r1fp32Stack ( stack , tok ) class ( r1fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( in ) :: tok (:) stack % top_index = stack % top_index + 1 stack % tokens (:, stack % top_index ) = tok (:) endsubroutine Push_r1fp32Stack","tags":"","loc":"proc/push_r1fp32stack.html"},{"title":"Push_r1fp64Stack – FEQParse","text":"public subroutine Push_r1fp64Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:) Contents Source Code Push_r1fp64Stack Source Code subroutine Push_r1fp64Stack ( stack , tok ) class ( r1fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( in ) :: tok (:) stack % top_index = stack % top_index + 1 stack % tokens (:, stack % top_index ) = tok (:) endsubroutine Push_r1fp64Stack","tags":"","loc":"proc/push_r1fp64stack.html"},{"title":"Push_r2fp32Stack – FEQParse","text":"public subroutine Push_r2fp32Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:,:) Contents Source Code Push_r2fp32Stack Source Code subroutine Push_r2fp32Stack ( stack , tok ) class ( r2fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( in ) :: tok (:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:, stack % top_index ) = tok (:,:) endsubroutine Push_r2fp32Stack","tags":"","loc":"proc/push_r2fp32stack.html"},{"title":"Push_r2fp64Stack – FEQParse","text":"public subroutine Push_r2fp64Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:,:) Contents Source Code Push_r2fp64Stack Source Code subroutine Push_r2fp64Stack ( stack , tok ) class ( r2fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( in ) :: tok (:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:, stack % top_index ) = tok (:,:) endsubroutine Push_r2fp64Stack","tags":"","loc":"proc/push_r2fp64stack.html"},{"title":"Push_r3fp32Stack – FEQParse","text":"public subroutine Push_r3fp32Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:,:,:) Contents Source Code Push_r3fp32Stack Source Code subroutine Push_r3fp32Stack ( stack , tok ) class ( r3fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( in ) :: tok (:,:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:,:, stack % top_index ) = tok (:,:,:) endsubroutine Push_r3fp32Stack","tags":"","loc":"proc/push_r3fp32stack.html"},{"title":"Push_r3fp64Stack – FEQParse","text":"public subroutine Push_r3fp64Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:,:,:) Contents Source Code Push_r3fp64Stack Source Code subroutine Push_r3fp64Stack ( stack , tok ) class ( r3fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( in ) :: tok (:,:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:,:, stack % top_index ) = tok (:,:,:) endsubroutine Push_r3fp64Stack","tags":"","loc":"proc/push_r3fp64stack.html"},{"title":"Push_r4fp32Stack – FEQParse","text":"public subroutine Push_r4fp32Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:,:,:,:) Contents Source Code Push_r4fp32Stack Source Code subroutine Push_r4fp32Stack ( stack , tok ) class ( r4fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( in ) :: tok (:,:,:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:,:,:, stack % top_index ) = tok (:,:,:,:) endsubroutine Push_r4fp32Stack","tags":"","loc":"proc/push_r4fp32stack.html"},{"title":"Push_r4fp64Stack – FEQParse","text":"public subroutine Push_r4fp64Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:,:,:,:) Contents Source Code Push_r4fp64Stack Source Code subroutine Push_r4fp64Stack ( stack , tok ) class ( r4fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( in ) :: tok (:,:,:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:,:,:, stack % top_index ) = tok (:,:,:,:) endsubroutine Push_r4fp64Stack","tags":"","loc":"proc/push_r4fp64stack.html"},{"title":"Push_sfp32Stack – FEQParse","text":"public subroutine Push_sfp32Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( sfp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok Contents Source Code Push_sfp32Stack Source Code subroutine Push_sfp32Stack ( stack , tok ) class ( sfp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( in ) :: tok stack % top_index = stack % top_index + 1 stack % tokens ( stack % top_index ) = tok endsubroutine Push_sfp32Stack","tags":"","loc":"proc/push_sfp32stack.html"},{"title":"Push_sfp64Stack – FEQParse","text":"public subroutine Push_sfp64Stack(stack, tok) Arguments Type Intent Optional Attributes Name class( sfp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok Contents Source Code Push_sfp64Stack Source Code subroutine Push_sfp64Stack ( stack , tok ) class ( sfp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( in ) :: tok stack % top_index = stack % top_index + 1 stack % tokens ( stack % top_index ) = tok endsubroutine Push_sfp64Stack","tags":"","loc":"proc/push_sfp64stack.html"},{"title":"FEQParse – FEQParse","text":"Uses FEQParse_TokenStack iso_fortran_env FEQParse_Functions FEQParse_FloatStacks Contents Variables Stack_Length nSeparators numbers operators pi_real32 pi_real64 separators Enumerations Interfaces EquationParser Derived Types EquationParser IndepVar Functions Construct_EquationParser Evaluate_r1fp32 Evaluate_r1fp64 Evaluate_r2fp32 Evaluate_r2fp64 Evaluate_r3fp32 Evaluate_r3fp64 Evaluate_r4fp32 Evaluate_r4fp64 Evaluate_sfp32 Evaluate_sfp64 IsFunction IsNumber IsOperator IsSeparator IsVariable Priority ReplaceStr Subroutines CleanEquation ConvertToPostFix Finalize_EquationParser Print_InfixTokens Print_PostfixTokens Tokenize Variables Type Visibility Attributes Name Initial integer, private, parameter :: Stack_Length = 256 integer, private, parameter :: nSeparators = 7 character(len=1), private :: numbers (10) = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] character(len=1), private :: operators (5) = ['+', '-', '*', '/', '&#94;'] real(kind=real32), public, parameter :: pi_real32 = 4.0_real32*atan(1.0_real32) real(kind=real64), public, parameter :: pi_real64 = 4.0_real64*atan(1.0_real64) character(len=1), private :: separators (7) = ['+', '-', '*', '/', \"(\", \")\", '&#94;'] Enumerations enum, bind(c) Enumerators enumerator :: None_Token = 0 enumerator :: Number_Token = 1 enumerator :: Variable_Token = 2 enumerator :: Operator_Token = 3 enumerator :: Function_Token = 4 enumerator :: OpeningParentheses_Token = 5 enumerator :: ClosingParentheses_Token = 6 enumerator :: Monadic_Token = 7 Interfaces public interface EquationParser private function Construct_EquationParser (equation, indepVars) result(parser) Arguments Type Intent Optional Attributes Name character :: equation character :: indepVars (:) Return Value type( EquationParser ) Derived Types type, public :: EquationParser Components Type Visibility Attributes Name Initial character, public, allocatable :: equation type( TokenStack ), public :: inFix character, public, allocatable :: inFixFormula type( IndepVar ), public, dimension(:), allocatable :: indepVars integer, public :: nIndepVars type( TokenStack ), public :: postFix character, public, allocatable :: variableName Constructor private  function Construct_EquationParser (equation, indepVars) Finalizations Procedures final :: Finalize_EquationParser Type-Bound Procedures procedure, public :: CleanEquation procedure, public :: ConvertToPostfix => ConvertToPostFix generic, public :: Evaluate => Evaluate_sfp32, Evaluate_sfp64, Evaluate_r1fp32, Evaluate_r1fp64, Evaluate_r2fp32, Evaluate_r2fp64, Evaluate_r3fp32, Evaluate_r3fp64, Evaluate_r4fp32, Evaluate_r4fp64 procedure, private :: Evaluate_r1fp32 procedure, private :: Evaluate_r1fp64 procedure, private :: Evaluate_r2fp32 procedure, private :: Evaluate_r2fp64 procedure, private :: Evaluate_r3fp32 procedure, private :: Evaluate_r3fp64 procedure, private :: Evaluate_r4fp32 procedure, private :: Evaluate_r4fp64 procedure, private :: Evaluate_sfp32 procedure, private :: Evaluate_sfp64 procedure, public :: Print_InFixTokens => Print_InfixTokens procedure, public :: Print_PostFixTokens => Print_PostfixTokens procedure, private, nopass :: Priority procedure, public :: Tokenize type, private :: IndepVar Components Type Visibility Attributes Name Initial character, private, allocatable :: value Functions private function Construct_EquationParser (equation, indepVars) result(parser) Arguments Type Intent Optional Attributes Name character :: equation character :: indepVars (:) Return Value type( EquationParser ) private function Evaluate_r1fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1)) private function Evaluate_r1fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1)) private function Evaluate_r2fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2)) private function Evaluate_r2fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2)) private function Evaluate_r3fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3)) private function Evaluate_r3fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3)) private function Evaluate_r4fp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (:,:,:,:,:) Return Value real(kind=real32)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3),lbound(x,4):ubound(x,4)) private function Evaluate_r4fp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (:,:,:,:,:) Return Value real(kind=real64)(lbound(x,1):ubound(x,1),lbound(x,2):ubound(x,2),lbound(x,3):ubound(x,3),lbound(x,4):ubound(x,4)) private function Evaluate_sfp32 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real32) :: x (1:parser%nIndepVars) Return Value real(kind=real32) private function Evaluate_sfp64 (parser, x) result(f) Arguments Type Intent Optional Attributes Name class( EquationParser ) :: parser real(kind=real64) :: x (1:parser%nIndepVars) Return Value real(kind=real64) private function IsFunction (varlen, eqChar, idx) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: varlen character, intent(in) :: eqChar integer, intent(out) :: idx Return Value logical private function IsNumber (eqChar) Arguments Type Intent Optional Attributes Name character(len=1) :: eqChar Return Value logical private function IsOperator (eqChar) Arguments Type Intent Optional Attributes Name character(len=1) :: eqChar Return Value logical private function IsSeparator (eqChar) Arguments Type Intent Optional Attributes Name character(len=1) :: eqChar Return Value logical private function IsVariable (varlen, eqChar, variables, nvariables) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: varlen character, intent(in) :: eqChar type( IndepVar ) :: variables (1:nvariables) integer :: nvariables Return Value logical private function Priority (toke) Arguments Type Intent Optional Attributes Name type( Token ) :: toke Return Value integer private pure recursive function ReplaceStr (string, search, substitute) result(modifiedString) Arguments Type Intent Optional Attributes Name character, intent(in) :: string character, intent(in) :: search character, intent(in) :: substitute Return Value character,allocatable Subroutines private subroutine CleanEquation (parser, equationCleaned) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(inout) :: parser logical, intent(out) :: equationCleaned private subroutine ConvertToPostFix (parser) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(inout) :: parser private subroutine Finalize_EquationParser (parser) Arguments Type Intent Optional Attributes Name type( EquationParser ), intent(inout) :: parser private subroutine Print_InfixTokens (parser) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(in) :: parser private subroutine Print_PostfixTokens (parser) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(in) :: parser private subroutine Tokenize (parser, tokenized, errorMsg) Arguments Type Intent Optional Attributes Name class( EquationParser ), intent(inout) :: parser logical, intent(out) :: tokenized character, intent(out), allocatable :: errorMsg","tags":"","loc":"module/feqparse.html"},{"title":"FEQParse_TokenStack – FEQParse","text":"Uses iso_fortran_env Contents Derived Types Token TokenStack Functions Copy IsEmpty_TokenStack TopToken Subroutines Construct_TokenStack Finalize_TokenStack Pop_TokenStack Push_TokenStack Derived Types type, public :: Token Components Type Visibility Attributes Name Initial integer, public :: tokenIndex character(len=48), public :: tokenString integer, public :: tokenType Type-Bound Procedures procedure, public :: Copy type, public :: TokenStack Components Type Visibility Attributes Name Initial type( Token ), public, allocatable :: tokens (:) integer, public :: top_index = 0 Type-Bound Procedures procedure, public :: Construct => Construct_TokenStack procedure, public :: Finalize => Finalize_TokenStack procedure, public :: IsEmpty => IsEmpty_TokenStack procedure, public :: Pop => Pop_TokenStack procedure, public :: Push => Push_TokenStack procedure, public :: TopToken Functions public function Copy (this) result(that) Arguments Type Intent Optional Attributes Name class( Token ) :: this Return Value type( Token ) public function IsEmpty_TokenStack (stack) Arguments Type Intent Optional Attributes Name class( TokenStack ) :: stack Return Value logical public function TopToken (stack) Arguments Type Intent Optional Attributes Name class( TokenStack ) :: stack Return Value type( Token ) Subroutines public subroutine Construct_TokenStack (stack, N) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(out) :: stack integer, intent(in) :: N public subroutine Finalize_TokenStack (stack) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(inout) :: stack public subroutine Pop_TokenStack (stack, tok) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(inout) :: stack type( Token ), intent(out) :: tok public subroutine Push_TokenStack (stack, tok) Arguments Type Intent Optional Attributes Name class( TokenStack ), intent(inout) :: stack type( Token ), intent(in) :: tok","tags":"","loc":"module/feqparse_tokenstack.html"},{"title":"FEQParse_Functions – FEQParse","text":"Uses iso_fortran_env Contents Variables Functions isInitialized maxFunctionLength maxFunctions nFunctions Enumerations Interfaces AddFunction Tuple f32 f64 randomize_r32 randomize_r64 Derived Types FEQParse_Function Tuple Functions ToUpperCase Tuple_new abs32 abs64 acos32 acos64 asin32 asin64 atan32 atan64 character_eq_function character_neq_function cos32 cos64 cosh32 cosh64 exp32 exp64 function_eq_character function_neq_character invoke32 invoke64 log1032 log1064 log32 log64 rand32 rand64 sech32 sech64 sin32 sin64 sinh32 sinh64 sqrt32 sqrt64 tan32 tan64 tanh32 tanh64 Subroutines AddFunction32 AddFunction64 Function_Finalize InitializeFunctions Tuple_Finalize character_array_assign_function character_assign_function Variables Type Visibility Attributes Name Initial type( FEQParse_Function ), public :: Functions (maxFunctions) logical, public :: isInitialized = .false. integer, public :: maxFunctionLength = 0 integer, public, parameter :: maxFunctions = 100 integer, public :: nFunctions = 17 Enumerations enum, bind(c) Enumerators enumerator :: cos_function = 1 enumerator :: cosh_function = 2 enumerator :: sin_function = 3 enumerator :: sinh_function = 4 enumerator :: tan_function = 5 enumerator :: tanh_function = 6 enumerator :: sqrt_function = 7 enumerator :: abs_function = 8 enumerator :: exp_function = 9 enumerator :: ln_function = 10 enumerator :: log_function = 11 enumerator :: log10_function = 12 enumerator :: acos_function = 13 enumerator :: asin_function = 14 enumerator :: atan_function = 15 enumerator :: sech_function = 16 enumerator :: rand_function = 17 Interfaces public interface AddFunction private subroutine AddFunction32 (name, f_32) Arguments Type Intent Optional Attributes Name character, intent(in) :: name procedure( f32 ) :: f_32 private subroutine AddFunction64 (name, f_64) Arguments Type Intent Optional Attributes Name character, intent(in) :: name procedure( f64 ) :: f_64 public interface Tuple private function Tuple_new (item1, item2) result(t) Arguments Type Intent Optional Attributes Name character, intent(in) :: item1 character, intent(in) :: item2 Return Value type( Tuple ) interface private pure function f32(x) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) interface private pure function f64(x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) interface private pure function randomize_r32() Arguments None Return Value real(kind=real32) interface private pure function randomize_r64() Arguments None Return Value real(kind=real64) Derived Types type, public :: FEQParse_Function Components Type Visibility Attributes Name Initial character, public, allocatable :: caps integer, public :: len procedure( f32 ), public, nopass, pointer :: ptr32 => null() procedure( f64 ), public, nopass, pointer :: ptr64 => null() character, public, allocatable :: str Finalizations Procedures final :: Function_Finalize Type-Bound Procedures generic, public :: assignment(=) => character_assign_function, character_array_assign_function procedure, private, pass(lhs) :: character_array_assign_function procedure, private, pass(lhs) :: character_assign_function procedure, private, pass(rhs) :: character_eq_function procedure, private, pass(rhs) :: character_neq_function procedure, private, pass(lhs) :: function_eq_character procedure, private, pass(lhs) :: function_neq_character generic, public :: invoke => invoke32, invoke64 procedure, private, pass(this) :: invoke32 procedure, private, pass(this) :: invoke64 generic, public :: operator(/=) => function_neq_character, character_neq_function generic, public :: operator(==) => function_eq_character, character_eq_function type, public :: Tuple Components Type Visibility Attributes Name Initial character, private, allocatable :: item1 character, private, allocatable :: item2 Constructor private  function Tuple_new (item1, item2) Finalizations Procedures final :: Tuple_Finalize Functions private pure function ToUpperCase (str) result(res) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character private function Tuple_new (item1, item2) result(t) Arguments Type Intent Optional Attributes Name character, intent(in) :: item1 character, intent(in) :: item2 Return Value type( Tuple ) private pure function abs32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function abs64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function acos32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function acos64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function asin32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function asin64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function atan32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function atan64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private elemental function character_eq_function (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs class( FEQParse_Function ), intent(in) :: rhs Return Value logical private elemental function character_neq_function (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs class( FEQParse_Function ), intent(in) :: rhs Return Value logical private pure function cos32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function cos64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function cosh32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function cosh64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function exp32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function exp64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private elemental function function_eq_character (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value logical private elemental function function_neq_character (lhs, rhs) result(ok) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value logical private elemental function invoke32 (this, x) result(fx) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: this real(kind=real32), intent(in) :: x Return Value real(kind=real32) private elemental function invoke64 (this, x) result(fx) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(in) :: this real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function log1032 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function log1064 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function log32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function log64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function rand32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function rand64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function sech32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function sech64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function sin32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function sin64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function sinh32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function sinh64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function sqrt32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function sqrt64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function tan32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function tan64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) private pure function tanh32 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) private pure function tanh64 (x) result(fx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Subroutines private subroutine AddFunction32 (name, f_32) Arguments Type Intent Optional Attributes Name character, intent(in) :: name procedure( f32 ) :: f_32 private subroutine AddFunction64 (name, f_64) Arguments Type Intent Optional Attributes Name character, intent(in) :: name procedure( f64 ) :: f_64 private subroutine Function_Finalize (this) Arguments Type Intent Optional Attributes Name type( FEQParse_Function ), intent(inout) :: this public subroutine InitializeFunctions () Arguments None private subroutine Tuple_Finalize (this) Arguments Type Intent Optional Attributes Name type( Tuple ), intent(inout) :: this private subroutine character_array_assign_function (lhs, rhs) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(inout) :: lhs Left hand side. class( Tuple ), intent(in) :: rhs Right hand side. private subroutine character_assign_function (lhs, rhs) Arguments Type Intent Optional Attributes Name class( FEQParse_Function ), intent(inout) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side.","tags":"","loc":"module/feqparse_functions.html"},{"title":"FEQParse_FloatStacks – FEQParse","text":"Uses iso_fortran_env Contents Derived Types feqparse_floatstack r1fp32Stack r1fp64Stack r2fp32Stack r2fp64Stack r3fp32Stack r3fp64Stack r4fp32Stack r4fp64Stack sfp32Stack sfp64Stack Subroutines Construct_r1fp32Stack Construct_r1fp64Stack Construct_r2fp32Stack Construct_r2fp64Stack Construct_r3fp32Stack Construct_r3fp64Stack Construct_r4fp32Stack Construct_r4fp64Stack Construct_sfp32Stack Construct_sfp64Stack Finalize_r1fp32Stack Finalize_r1fp64Stack Finalize_r2fp32Stack Finalize_r2fp64Stack Finalize_r3fp32Stack Finalize_r3fp64Stack Finalize_r4fp32Stack Finalize_r4fp64Stack Finalize_sfp32Stack Finalize_sfp64Stack Pop_r1fp32Stack Pop_r1fp64Stack Pop_r2fp32Stack Pop_r2fp64Stack Pop_r3fp32Stack Pop_r3fp64Stack Pop_r4fp32Stack Pop_r4fp64Stack Pop_sfp32Stack Pop_sfp64Stack Push_r1fp32Stack Push_r1fp64Stack Push_r2fp32Stack Push_r2fp64Stack Push_r3fp32Stack Push_r3fp64Stack Push_r4fp32Stack Push_r4fp64Stack Push_sfp32Stack Push_sfp64Stack Derived Types type, public :: feqparse_floatstack Components Type Visibility Attributes Name Initial integer, public :: top_index type, public, extends( feqparse_floatstack ) :: r1fp32Stack Components Type Visibility Attributes Name Initial real(kind=real32), public, allocatable :: tokens (:,:) integer, public :: top_index Finalizations Procedures final :: Finalize_r1fp32Stack Type-Bound Procedures procedure, public :: Construct => Construct_r1fp32Stack procedure, public :: Pop => Pop_r1fp32Stack procedure, public :: Push => Push_r1fp32Stack type, public, extends( feqparse_floatstack ) :: r1fp64Stack Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: tokens (:,:) integer, public :: top_index Finalizations Procedures final :: Finalize_r1fp64Stack Type-Bound Procedures procedure, public :: Construct => Construct_r1fp64Stack procedure, public :: Pop => Pop_r1fp64Stack procedure, public :: Push => Push_r1fp64Stack type, public, extends( feqparse_floatstack ) :: r2fp32Stack Components Type Visibility Attributes Name Initial real(kind=real32), public, allocatable :: tokens (:,:,:) integer, public :: top_index Finalizations Procedures final :: Finalize_r2fp32Stack Type-Bound Procedures procedure, public :: Construct => Construct_r2fp32Stack procedure, public :: Pop => Pop_r2fp32Stack procedure, public :: Push => Push_r2fp32Stack type, public, extends( feqparse_floatstack ) :: r2fp64Stack Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: tokens (:,:,:) integer, public :: top_index Finalizations Procedures final :: Finalize_r2fp64Stack Type-Bound Procedures procedure, public :: Construct => Construct_r2fp64Stack procedure, public :: Pop => Pop_r2fp64Stack procedure, public :: Push => Push_r2fp64Stack type, public, extends( feqparse_floatstack ) :: r3fp32Stack Components Type Visibility Attributes Name Initial real(kind=real32), public, allocatable :: tokens (:,:,:,:) integer, public :: top_index Finalizations Procedures final :: Finalize_r3fp32Stack Type-Bound Procedures procedure, public :: Construct => Construct_r3fp32Stack procedure, public :: Pop => Pop_r3fp32Stack procedure, public :: Push => Push_r3fp32Stack type, public, extends( feqparse_floatstack ) :: r3fp64Stack Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: tokens (:,:,:,:) integer, public :: top_index Finalizations Procedures final :: Finalize_r3fp64Stack Type-Bound Procedures procedure, public :: Construct => Construct_r3fp64Stack procedure, public :: Pop => Pop_r3fp64Stack procedure, public :: Push => Push_r3fp64Stack type, public, extends( feqparse_floatstack ) :: r4fp32Stack Components Type Visibility Attributes Name Initial real(kind=real32), public, allocatable :: tokens (:,:,:,:,:) integer, public :: top_index Finalizations Procedures final :: Finalize_r4fp32Stack Type-Bound Procedures procedure, public :: Construct => Construct_r4fp32Stack procedure, public :: Pop => Pop_r4fp32Stack procedure, public :: Push => Push_r4fp32Stack type, public, extends( feqparse_floatstack ) :: r4fp64Stack Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: tokens (:,:,:,:,:) integer, public :: top_index Finalizations Procedures final :: Finalize_r4fp64Stack Type-Bound Procedures procedure, public :: Construct => Construct_r4fp64Stack procedure, public :: Pop => Pop_r4fp64Stack procedure, public :: Push => Push_r4fp64Stack type, public, extends( feqparse_floatstack ) :: sfp32Stack Components Type Visibility Attributes Name Initial real(kind=real32), public, allocatable :: tokens (:) integer, public :: top_index Finalizations Procedures final :: Finalize_sfp32Stack Type-Bound Procedures procedure, public :: Construct => Construct_sfp32Stack procedure, public :: Pop => Pop_sfp32Stack procedure, public :: Push => Push_sfp32Stack type, public, extends( feqparse_floatstack ) :: sfp64Stack Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: tokens (:) integer, public :: top_index Finalizations Procedures final :: Finalize_sfp64Stack Type-Bound Procedures procedure, public :: Construct => Construct_sfp64Stack procedure, public :: Pop => Pop_sfp64Stack procedure, public :: Push => Push_sfp64Stack Subroutines public subroutine Construct_r1fp32Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r1fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:) public subroutine Construct_r1fp64Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r1fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:) public subroutine Construct_r2fp32Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r2fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:,:) public subroutine Construct_r2fp64Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r2fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:,:) public subroutine Construct_r3fp32Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r3fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:,:,:) public subroutine Construct_r3fp64Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r3fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:,:,:) public subroutine Construct_r4fp32Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r4fp32Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real32), intent(in) :: mold (:,:,:,:) public subroutine Construct_r4fp64Stack (stack, N, mold) Arguments Type Intent Optional Attributes Name class( r4fp64Stack ), intent(out) :: stack integer, intent(in) :: N real(kind=real64), intent(in) :: mold (:,:,:,:) public subroutine Construct_sfp32Stack (stack, N) Arguments Type Intent Optional Attributes Name class( sfp32Stack ), intent(out) :: stack integer, intent(in) :: N public subroutine Construct_sfp64Stack (stack, N) Arguments Type Intent Optional Attributes Name class( sfp64Stack ), intent(out) :: stack integer, intent(in) :: N public subroutine Finalize_r1fp32Stack (stack) Arguments Type Intent Optional Attributes Name type( r1fp32Stack ), intent(inout) :: stack public subroutine Finalize_r1fp64Stack (stack) Arguments Type Intent Optional Attributes Name type( r1fp64Stack ), intent(inout) :: stack public subroutine Finalize_r2fp32Stack (stack) Arguments Type Intent Optional Attributes Name type( r2fp32Stack ), intent(inout) :: stack public subroutine Finalize_r2fp64Stack (stack) Arguments Type Intent Optional Attributes Name type( r2fp64Stack ), intent(inout) :: stack public subroutine Finalize_r3fp32Stack (stack) Arguments Type Intent Optional Attributes Name type( r3fp32Stack ), intent(inout) :: stack public subroutine Finalize_r3fp64Stack (stack) Arguments Type Intent Optional Attributes Name type( r3fp64Stack ), intent(inout) :: stack public subroutine Finalize_r4fp32Stack (stack) Arguments Type Intent Optional Attributes Name type( r4fp32Stack ), intent(inout) :: stack public subroutine Finalize_r4fp64Stack (stack) Arguments Type Intent Optional Attributes Name type( r4fp64Stack ), intent(inout) :: stack public subroutine Finalize_sfp32Stack (stack) Arguments Type Intent Optional Attributes Name type( sfp32Stack ), intent(inout) :: stack public subroutine Finalize_sfp64Stack (stack) Arguments Type Intent Optional Attributes Name type( sfp64Stack ), intent(inout) :: stack public subroutine Pop_r1fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:) public subroutine Pop_r1fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:) public subroutine Pop_r2fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:,:) public subroutine Pop_r2fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:,:) public subroutine Pop_r3fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:,:,:) public subroutine Pop_r3fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:,:,:) public subroutine Pop_r4fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok (:,:,:,:) public subroutine Pop_r4fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok (:,:,:,:) public subroutine Pop_sfp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( sfp32Stack ), intent(inout) :: stack real(kind=real32), intent(out) :: tok public subroutine Pop_sfp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( sfp64Stack ), intent(inout) :: stack real(kind=real64), intent(out) :: tok public subroutine Push_r1fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:) public subroutine Push_r1fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r1fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:) public subroutine Push_r2fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:,:) public subroutine Push_r2fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r2fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:,:) public subroutine Push_r3fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:,:,:) public subroutine Push_r3fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r3fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:,:,:) public subroutine Push_r4fp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok (:,:,:,:) public subroutine Push_r4fp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( r4fp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok (:,:,:,:) public subroutine Push_sfp32Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( sfp32Stack ), intent(inout) :: stack real(kind=real32), intent(in) :: tok public subroutine Push_sfp64Stack (stack, tok) Arguments Type Intent Optional Attributes Name class( sfp64Stack ), intent(inout) :: stack real(kind=real64), intent(in) :: tok","tags":"","loc":"module/feqparse_floatstacks.html"},{"title":"FEQParse.f90 – FEQParse","text":"Contents Modules FEQParse Source Code FEQParse.f90 Source Code ! FEQParse.F03 ! ! Copyright 2020 Fluid Numerics LLC ! All rights reserved. ! ! Author : Joe Schoonover ( joe@fluidnumerics.com ) ! ! EquationParser defines a public class that can be used to parse and evaluate strings ! representative of equations. An equation, written in infix form, is converted to ! postfix form and evaluated using a postfix calculator. ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! module FEQParse use iso_fortran_env use FEQParse_Functions use FEQParse_TokenStack use FEQParse_FloatStacks implicit none public :: FEQParse_Function , & AddFunction real ( real64 ), parameter :: pi_real64 = 4.0_real64 * atan ( 1.0_real64 ) real ( real32 ), parameter :: pi_real32 = 4.0_real32 * atan ( 1.0_real32 ) integer , parameter , private :: Stack_Length = 256 ! Token types enum , bind ( c ) enumerator :: None_Token = 0 enumerator :: Number_Token = 1 enumerator :: Variable_Token = 2 enumerator :: Operator_Token = 3 enumerator :: Function_Token = 4 enumerator :: OpeningParentheses_Token = 5 enumerator :: ClosingParentheses_Token = 6 enumerator :: Monadic_Token = 7 endenum integer , parameter , private :: nSeparators = 7 character ( 1 ), private :: separators ( 7 ) = [ '+' , '-' , '*' , '/' , \"(\" , \")\" , '&#94;' ] character ( 1 ), private :: operators ( 5 ) = [ '+' , '-' , '*' , '/' , '&#94;' ] character ( 1 ), private :: numbers ( 10 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] ! Private Types ! private type IndepVar character (:), allocatable :: value endtype type , public :: EquationParser character (:), allocatable :: equation character (:), allocatable :: variableName character (:), allocatable :: inFixFormula integer :: nIndepVars type ( IndepVar ), dimension (:), allocatable :: indepVars type ( TokenStack ) :: inFix type ( TokenStack ) :: postFix contains final :: Finalize_EquationParser procedure :: CleanEquation procedure :: Tokenize procedure :: ConvertToPostfix generic :: Evaluate => Evaluate_sfp32 , Evaluate_sfp64 , & Evaluate_r1fp32 , Evaluate_r1fp64 , & Evaluate_r2fp32 , Evaluate_r2fp64 , & Evaluate_r3fp32 , Evaluate_r3fp64 , & Evaluate_r4fp32 , Evaluate_r4fp64 procedure , private :: Evaluate_sfp32 , Evaluate_sfp64 procedure , private :: Evaluate_r1fp32 , Evaluate_r1fp64 procedure , private :: Evaluate_r2fp32 , Evaluate_r2fp64 procedure , private :: Evaluate_r3fp32 , Evaluate_r3fp64 procedure , private :: Evaluate_r4fp32 , Evaluate_r4fp64 procedure :: Print_InFixTokens procedure :: Print_PostFixTokens procedure , nopass , private :: Priority endtype EquationParser interface EquationParser procedure Construct_EquationParser endinterface EquationParser contains function Construct_EquationParser ( equation , indepVars ) result ( parser ) type ( EquationParser ) :: parser character ( * ) :: equation character ( * ) :: indepVars (:) ! Local integer :: i character (:), allocatable :: errorMsg logical :: equationIsClean , tokenized , success integer :: nIndepVars call InitializeFunctions () nIndepVars = size ( indepVars ) allocate ( parser % indepVars ( 1 : nIndepVars )) parser % nIndepVars = nIndepVars do i = 1 , nIndepVars parser % indepVars ( i )% value = trim ( indepVars ( i )) enddo parser % equation = trim ( equation ) if ( allocated ( parser % inFixFormula )) deallocate ( parser % inFixFormula ) allocate ( character ( len ( parser % equation ) + maxFunctionLength + 1 ) :: parser % inFixFormula ) parser % variableName = '#noname' call parser % CleanEquation ( equationIsClean ) if ( equationIsClean ) then call parser % Tokenize ( tokenized , errorMsg ) if ( tokenized ) then call parser % ConvertToPostFix () else if ( allocated ( errorMsg )) print * , trim ( errorMsg ) success = . false . endif endif endfunction Construct_EquationParser subroutine Finalize_EquationParser ( parser ) type ( EquationParser ), intent ( inout ) :: parser ! Local integer :: i if ( allocated ( parser % inFixFormula )) deallocate ( parser % inFixFormula ) if ( allocated ( parser % equation )) deallocate ( parser % equation ) if ( allocated ( parser % variableName )) deallocate ( parser % variableName ) if ( allocated ( parser % indepVars )) then do i = 1 , parser % nIndepVars deallocate ( parser % indepVars ( i )% value ) enddo deallocate ( parser % indepVars ) endif call parser % infix % Finalize () call parser % postfix % Finalize () endsubroutine Finalize_EquationParser subroutine CleanEquation ( parser , equationCleaned ) class ( EquationParser ), intent ( inout ) :: parser logical , intent ( out ) :: equationCleaned ! Local integer :: nChar , equalSignLoc , j , i , n character (:), allocatable :: infixformula equationCleaned = . false . equalSignLoc = index ( parser % equation , '=' ) if ( equalSignLoc /= 0 ) then parser % variableName = parser % equation ( 1 : equalSignLoc - 1 ) endif !Replace ** for &#94; parser % equation = ReplaceStr ( parser % equation , '**' , '&#94;' ) nChar = len_trim ( parser % equation ) ! Grab the formula to the right of the equal sign and left adjust the formula inFixFormula = parser % equation ( equalSignLoc + 1 :) ! Remove any spaces j = 1 n = len ( inFixFormula ) do i = 1 , n if ( inFixFormula ( i : i ) /= ' ' ) then parser % inFixFormula ( j : j ) = inFixFormula ( i : i ) j = j + 1 endif enddo parser % inFixFormula ( j :) = ' ' equationCleaned = . true . endsubroutine CleanEquation pure recursive function ReplaceStr ( string , search , substitute ) result ( modifiedString ) implicit none character ( * ), intent ( in ) :: string , search , substitute character (:), allocatable :: modifiedString integer :: i , stringLen , searchLen stringLen = len ( string ) searchLen = len ( search ) if ( stringLen == 0 . or . searchLen == 0 ) then modifiedString = '' return elseif ( stringLen < searchLen ) then modifiedString = string return endif i = 1 do if ( string ( i : i + searchLen - 1 ) == search ) then modifiedString = string ( 1 : i - 1 ) // substitute // replaceStr ( string ( i + searchLen : stringLen ), search , substitute ) exit endif if ( i + searchLen > stringLen ) then modifiedString = string exit endif i = i + 1 cycle enddo endfunction ReplaceStr subroutine Tokenize ( parser , tokenized , errorMsg ) class ( EquationParser ), intent ( inout ) :: parser logical , intent ( out ) :: tokenized character (:), allocatable , intent ( out ) :: errorMsg ! Local integer :: i , j , k , id integer , allocatable :: maxVarLen , varLen tokenized = . false . call parser % infix % Construct ( Stack_Length ) maxVarLen = 0 do k = 1 , parser % nIndepVars maxVarLen = max ( maxVarLen , len ( parser % indepVars ( k )% value )) enddo i = 1 do while ( parser % inFixFormula ( i : i ) /= ' ' ) varLen = maxVarLen if ( IsFunction ( j , parser % infixFormula ( i : i + maxFunctionLength ), id )) then parser % inFix % top_index = parser % inFix % top_index + 1 parser % inFix % tokens ( parser % inFix % top_index )% tokenString = parser % inFixFormula ( i : i + j - 1 ) parser % inFix % tokens ( parser % inFix % top_index )% tokenType = Function_Token parser % inFix % tokens ( parser % inFix % top_index )% tokenIndex = id i = i + j elseif ( IsVariable ( varLen , parser % inFixFormula ( i : i + varLen - 1 ), parser % indepVars , parser % nIndepVars )) then parser % inFix % top_index = parser % inFix % top_index + 1 parser % inFix % tokens ( parser % inFix % top_index )% tokenString = parser % inFixFormula ( i : i + varLen - 1 ) parser % inFix % tokens ( parser % inFix % top_index )% tokenType = Variable_Token i = i + varLen ! Next item must be an operator, closing parentheses, or end of equation if (. not . IsOperator ( parser % infixFormula ( i : i )) . and . & parser % inFixFormula ( i : i ) /= ')' . and . parser % inFixFormula ( i : i ) /= ' ' ) then errorMsg = 'Missing operator or closing parentheses after token : ' // & trim ( parser % inFix % tokens ( parser % inFix % top_index )% tokenString ) return endif elseif ( IsNumber ( parser % inFixFormula ( i : i ))) then parser % inFix % top_index = parser % inFix % top_index + 1 parser % inFix % tokens ( parser % inFix % top_index )% tokenString = '' if ( parser % inFixFormula ( i : i ) == 'p' . or . parser % inFixFormula ( i : i ) == 'P' ) then ! Conditional for using built in 'pi' definition parser % inFix % tokens ( parser % inFix % top_index )% tokenString ( 1 : 2 ) = parser % inFixFormula ( i : i + 1 ) j = 2 else j = 0 do while ( IsNumber ( parser % inFixFormula ( i + j : i + j ))) parser % inFix % tokens ( parser % inFix % top_index )% tokenString ( j + 1 : j + 1 ) = parser % inFixFormula ( i + j : i + j ) j = j + 1 enddo endif parser % inFix % tokens ( parser % inFix % top_index )% tokenType = Number_Token i = i + j ! Next item must be an operator or a closing parentheses if (. not . IsOperator ( parser % infixFormula ( i : i )) . and . & parser % inFixFormula ( i : i ) /= ')' . and . parser % inFixFormula ( i : i ) /= ' ' ) then errorMsg = 'Missing operator or closing parentheses after token : ' // & trim ( parser % inFix % tokens ( parser % inFix % top_index )% tokenString ) return endif elseif ( IsSeparator ( parser % inFixFormula ( i : i ))) then parser % inFix % top_index = parser % inFix % top_index + 1 parser % inFix % tokens ( parser % inFix % top_index )% tokenString = parser % inFixFormula ( i : i ) if ( parser % inFixFormula ( i : i ) == '(' ) then parser % inFix % tokens ( parser % inFix % top_index )% tokenType = OpeningParentheses_Token elseif ( parser % inFixFormula ( i : i ) == ')' ) then parser % inFix % tokens ( parser % inFix % top_index )% tokenType = ClosingParentheses_Token else parser % inFix % tokens ( parser % inFix % top_index )% tokenType = Operator_Token endif i = i + 1 else errorMsg = 'Invalid Token : ' // & trim ( parser % inFixFormula ( i : i )) return endif enddo if ( parser % inFix % tokens ( 1 )% tokenType == Operator_Token ) then if ( trim ( parser % inFix % tokens ( 1 )% tokenString ) == '+' . or . & trim ( parser % inFix % tokens ( 1 )% tokenString ) == '-' ) then parser % inFix % tokens ( 1 )% tokenType = Monadic_Token endif endif do i = 2 , parser % inFix % top_index if ( parser % inFix % tokens ( i )% tokenType == Operator_Token . and . & parser % inFix % tokens ( i - 1 )% tokenType == OpeningParentheses_Token ) then parser % inFix % tokens ( i )% tokenType = Monadic_Token endif enddo tokenized = . true . endsubroutine Tokenize subroutine ConvertToPostFix ( parser ) class ( EquationParser ), intent ( inout ) :: parser ! Local type ( TokenStack ) :: operator_stack type ( Token ) :: tok integer :: i call parser % postfix % Construct ( Stack_Length ) call operator_stack % Construct ( Stack_Length ) do i = 1 , parser % infix % top_index if ( parser % inFix % tokens ( i )% tokenType == Variable_Token . or . & parser % inFix % tokens ( i )% tokenType == Number_Token ) then call parser % postFix % push ( parser % inFix % tokens ( i )) elseif ( parser % inFix % tokens ( i )% tokenType == Function_Token ) then call operator_stack % push ( parser % inFix % tokens ( i )) elseif ( parser % inFix % tokens ( i )% tokenType == Operator_Token & . or . parser % inFix % tokens ( i )% tokenType == Monadic_Token ) then if (. not . operator_stack % IsEmpty ()) then tok = operator_stack % TopToken () do while ( trim ( tok % tokenString ) /= '(' . and . & parser % Priority ( tok ) > & parser % Priority ( parser % inFix % tokens ( i )) . and . & . not . operator_stack % IsEmpty ()) call parser % postFix % push ( tok ) call operator_stack % pop ( tok ) tok = operator_stack % TopToken () enddo endif call operator_stack % push ( parser % inFix % tokens ( i )) elseif ( parser % inFix % tokens ( i )% tokenType == OpeningParentheses_Token ) then call operator_stack % push ( parser % inFix % tokens ( i )) elseif ( parser % inFix % tokens ( i )% tokenType == ClosingParentheses_Token ) then tok = operator_stack % TopToken () do while (. not .( operator_stack % IsEmpty ()) . and . tok % tokenString ( 1 : 1 ) /= '(' ) call parser % postFix % push ( tok ) call operator_stack % pop ( tok ) tok = operator_stack % TopToken () enddo ! Pop the opening parenthesis call operator_stack % pop ( tok ) endif enddo ! Pop the remaining operators do while (. not .( operator_stack % IsEmpty ())) tok = operator_stack % TopToken () call parser % postFix % push ( tok ) call operator_stack % pop ( tok ) enddo endsubroutine ConvertToPostFix function Evaluate_sfp32 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real32 ) :: x ( 1 : parser % nIndepVars ) real ( real32 ) :: f ! Local integer :: i , k type ( Token ) :: t type ( sfp32Stack ) :: stack real ( real32 ) :: v , a , b , c call stack % Construct ( Stack_Length ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real32 else read ( t % tokenString , * ) v endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x ( i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a endfunction Evaluate_sfp32 function Evaluate_sfp64 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real64 ) :: x ( 1 : parser % nIndepVars ) real ( real64 ) :: f ! Local integer :: i , k type ( Token ) :: t type ( sfp64Stack ) :: stack real ( real64 ) :: v , a , b , c call stack % Construct ( Stack_Length ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real64 else read ( t % tokenString , * ) v endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x ( i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a endfunction Evaluate_sfp64 function Evaluate_r1fp32 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real32 ) :: x (:,:) real ( real32 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 )) ! Local integer :: i , k type ( Token ) :: t type ( r1fp32Stack ) :: stack real ( real32 ) :: vnumber real ( real32 ), allocatable :: v (:) real ( real32 ), allocatable :: a (:) real ( real32 ), allocatable :: b (:) real ( real32 ), allocatable :: c (:) allocate ( v ( lbound ( x , 1 ): ubound ( x , 1 )), & a ( lbound ( x , 1 ): ubound ( x , 1 )), & b ( lbound ( x , 1 ): ubound ( x , 1 )), & c ( lbound ( x , 1 ): ubound ( x , 1 ))) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real32 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r1fp32 function Evaluate_r1fp64 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real64 ) :: x (:,:) real ( real64 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 )) ! Local integer :: i , k type ( Token ) :: t type ( r1fp64Stack ) :: stack real ( real64 ) :: vnumber real ( real64 ), allocatable :: v (:) real ( real64 ), allocatable :: a (:) real ( real64 ), allocatable :: b (:) real ( real64 ), allocatable :: c (:) allocate ( v ( lbound ( x , 1 ): ubound ( x , 1 )), & a ( lbound ( x , 1 ): ubound ( x , 1 )), & b ( lbound ( x , 1 ): ubound ( x , 1 )), & c ( lbound ( x , 1 ): ubound ( x , 1 ))) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real64 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r1fp64 function Evaluate_r2fp32 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real32 ) :: x (:,:,:) real ( real32 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 )) ! Local integer :: i , k type ( Token ) :: t type ( r2fp32Stack ) :: stack real ( real32 ) :: vnumber real ( real32 ), allocatable :: v (:,:) real ( real32 ), allocatable :: a (:,:) real ( real32 ), allocatable :: b (:,:) real ( real32 ), allocatable :: c (:,:) integer :: l1 , l2 , u1 , u2 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) allocate ( v ( l1 : u1 , l2 : u2 ), & a ( l1 : u1 , l2 : u2 ), & b ( l1 : u1 , l2 : u2 ), & c ( l1 : u1 , l2 : u2 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () print * , trim ( t % tokenString ) select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real32 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r2fp32 function Evaluate_r2fp64 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real64 ) :: x (:,:,:) real ( real64 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 )) ! Local integer :: i , k type ( Token ) :: t type ( r2fp64Stack ) :: stack real ( real64 ) :: vnumber real ( real64 ), allocatable :: v (:,:) real ( real64 ), allocatable :: a (:,:) real ( real64 ), allocatable :: b (:,:) real ( real64 ), allocatable :: c (:,:) integer :: l1 , l2 , u1 , u2 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) allocate ( v ( l1 : u1 , l2 : u2 ), & a ( l1 : u1 , l2 : u2 ), & b ( l1 : u1 , l2 : u2 ), & c ( l1 : u1 , l2 : u2 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real64 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r2fp64 function Evaluate_r3fp32 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real32 ) :: x (:,:,:,:) real ( real32 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 ), & lbound ( x , 3 ): ubound ( x , 3 )) ! Local integer :: i , k type ( Token ) :: t type ( r3fp32Stack ) :: stack real ( real32 ) :: vnumber real ( real32 ), allocatable :: v (:,:,:) real ( real32 ), allocatable :: a (:,:,:) real ( real32 ), allocatable :: b (:,:,:) real ( real32 ), allocatable :: c (:,:,:) integer :: l1 , l2 , l3 , u1 , u2 , u3 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) l3 = lbound ( x , 3 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) u3 = ubound ( x , 3 ) allocate ( v ( l1 : u1 , l2 : u2 , l3 : u3 ), & a ( l1 : u1 , l2 : u2 , l3 : u3 ), & b ( l1 : u1 , l2 : u2 , l3 : u3 ), & c ( l1 : u1 , l2 : u2 , l3 : u3 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real32 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r3fp32 function Evaluate_r3fp64 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real64 ) :: x (:,:,:,:) real ( real64 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 ), & lbound ( x , 3 ): ubound ( x , 3 )) ! Local integer :: i , k type ( Token ) :: t type ( r3fp64Stack ) :: stack real ( real64 ) :: vnumber real ( real64 ), allocatable :: v (:,:,:) real ( real64 ), allocatable :: a (:,:,:) real ( real64 ), allocatable :: b (:,:,:) real ( real64 ), allocatable :: c (:,:,:) integer :: l1 , l2 , l3 , u1 , u2 , u3 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) l3 = lbound ( x , 3 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) u3 = ubound ( x , 3 ) allocate ( v ( l1 : u1 , l2 : u2 , l3 : u3 ), & a ( l1 : u1 , l2 : u2 , l3 : u3 ), & b ( l1 : u1 , l2 : u2 , l3 : u3 ), & c ( l1 : u1 , l2 : u2 , l3 : u3 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real64 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r3fp64 function Evaluate_r4fp32 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real32 ) :: x (:,:,:,:,:) real ( real32 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 ), & lbound ( x , 3 ): ubound ( x , 3 ), & lbound ( x , 4 ): ubound ( x , 4 )) ! Local integer :: i , k type ( Token ) :: t type ( r4fp32Stack ) :: stack real ( real32 ) :: vnumber real ( real32 ), allocatable :: v (:,:,:,:) real ( real32 ), allocatable :: a (:,:,:,:) real ( real32 ), allocatable :: b (:,:,:,:) real ( real32 ), allocatable :: c (:,:,:,:) integer :: l1 , l2 , l3 , l4 , u1 , u2 , u3 , u4 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) l3 = lbound ( x , 3 ) l4 = lbound ( x , 3 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) u3 = ubound ( x , 3 ) u4 = ubound ( x , 4 ) allocate ( v ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & a ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & b ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & c ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real32 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:,:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r4fp32 function Evaluate_r4fp64 ( parser , x ) result ( f ) class ( EquationParser ) :: parser real ( real64 ) :: x (:,:,:,:,:) real ( real64 ) :: f ( lbound ( x , 1 ): ubound ( x , 1 ), & lbound ( x , 2 ): ubound ( x , 2 ), & lbound ( x , 3 ): ubound ( x , 3 ), & lbound ( x , 4 ): ubound ( x , 4 )) ! Local integer :: i , k type ( Token ) :: t type ( r4fp64Stack ) :: stack real ( real64 ) :: vnumber real ( real64 ), allocatable :: v (:,:,:,:) real ( real64 ), allocatable :: a (:,:,:,:) real ( real64 ), allocatable :: b (:,:,:,:) real ( real64 ), allocatable :: c (:,:,:,:) integer :: l1 , l2 , l3 , l4 , u1 , u2 , u3 , u4 l1 = lbound ( x , 1 ) l2 = lbound ( x , 2 ) l3 = lbound ( x , 3 ) l4 = lbound ( x , 3 ) u1 = ubound ( x , 1 ) u2 = ubound ( x , 2 ) u3 = ubound ( x , 3 ) u4 = ubound ( x , 4 ) allocate ( v ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & a ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & b ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 ), & c ( l1 : u1 , l2 : u2 , l3 : u3 , l4 : u4 )) call stack % Construct ( Stack_Length , v ) do k = 1 , parser % postfix % top_index t = parser % postfix % tokens ( k )% Copy () select case ( t % tokenType ) case ( Number_Token ) if ( t % tokenString == 'pi' . or . t % tokenString == 'PI' ) then v = pi_real64 else read ( t % tokenString , * ) vnumber v = vnumber endif call stack % Push ( v ) case ( Variable_Token ) do i = 1 , parser % nIndepVars if ( trim ( t % tokenString ) == parser % indepVars ( i )% value ) then call stack % Push ( x (:,:,:,:, i )) exit endif enddo case ( Operator_Token ) call stack % Pop ( a ) call stack % Pop ( b ) select case ( trim ( t % tokenString )) case ( '+' ) c = a + b case ( '-' ) c = b - a case ( '*' ) c = a * b case ( '/' ) c = b / a case ( '&#94;' ) c = b ** a case default endselect call stack % Push ( c ) case ( Function_Token ) call stack % Pop ( a ) b = Functions ( t % tokenIndex )% invoke ( a ) call stack % Push ( b ) case ( Monadic_Token ) if ( trim ( t % tokenString ) == '-' ) then call stack % Pop ( a ) a = - a call stack % Push ( a ) endif case default endselect enddo call stack % Pop ( a ) f = a deallocate ( v , a , b , c ) endfunction Evaluate_r4fp64 subroutine Print_InfixTokens ( parser ) class ( EquationParser ), intent ( in ) :: parser ! Local integer :: i do i = 1 , parser % inFix % top_index print * , trim ( parser % inFix % tokens ( i )% tokenString ) enddo endsubroutine Print_InfixTokens subroutine Print_PostfixTokens ( parser ) class ( EquationParser ), intent ( in ) :: parser ! Local integer :: i do i = 1 , parser % postFix % top_index print * , trim ( parser % postFix % tokens ( i )% tokenString ), parser % postFix % tokens ( i )% tokenType enddo endsubroutine Print_PostfixTokens ! Support Functions ! logical function IsSeparator ( eqChar ) character ( 1 ) :: eqChar ! Local integer :: i IsSeparator = . false . do i = 1 , nSeparators if ( eqChar == separators ( i )) then IsSeparator = . true . endif enddo endfunction IsSeparator logical function IsNumber ( eqChar ) character ( 1 ) :: eqChar ! Local integer :: i IsNumber = . false . if ( eqChar == '.' . or . eqChar == 'p' . or . eqChar == 'P' ) then IsNumber = . true . return endif do i = 1 , 10 if ( eqChar == numbers ( i )) then IsNumber = . true . return endif enddo endfunction IsNumber logical function IsVariable ( varlen , eqChar , variables , nvariables ) integer , intent ( inout ) :: varlen character ( * ), intent ( in ) :: eqChar integer :: nvariables type ( IndepVar ) :: variables ( 1 : nvariables ) ! Local integer :: i IsVariable = . false . varlen = 0 if ( any ( separators (:) == eqChar ( 1 : 1 ))) return if ( verify ( eqChar ( 1 : 1 ), '0123456789' ) == 0 ) return do i = 1 , nvariables if ( index ( eqChar , variables ( i )% value ) == 1 ) then IsVariable = . true . if ( len ( variables ( i )% value ) > varlen ) then varlen = len ( variables ( i )% value ) endif endif enddo endfunction IsVariable logical function IsOperator ( eqChar ) character ( 1 ) :: eqChar ! Local integer :: i IsOperator = . false . do i = 1 , 5 if ( eqChar == operators ( i )) then IsOperator = . true . return endif enddo endfunction IsOperator logical function IsFunction ( varlen , eqChar , idx ) integer , intent ( inout ) :: varlen character ( * ), intent ( in ) :: eqChar integer , intent ( out ) :: idx ! Local integer :: i IsFunction = . false . varlen = 0 if ( any ( separators (:) == eqChar ( 1 : 1 ))) return if ( verify ( eqChar ( 1 : 1 ), '0123456789' ) == 0 ) return do i = 1 , nFunctions if ( Functions ( i )% len <= len ( eqChar )) then if ( Functions ( i ) == eqChar (: Functions ( i )% len )) then if ( eqChar ( Functions ( i )% len + 1 : Functions ( i )% len + 1 ) == '(' ) then IsFunction = . true . varlen = max ( Functions ( i )% len , varlen ) idx = i endif endif endif enddo endfunction integer function Priority ( toke ) type ( Token ) :: toke if ( toke % tokenType == Function_Token ) then Priority = 5 elseif ( toke % tokenType == Operator_Token ) then if ( toke % tokenString ( 1 : 1 ) == '&#94;' ) then Priority = 4 elseif ( toke % tokenString ( 1 : 1 ) == '/' ) then Priority = 3 elseif ( toke % tokenString ( 1 : 1 ) == '*' ) then Priority = 2 elseif ( toke % tokenString ( 1 : 1 ) == '+' . or . toke % tokenString ( 1 : 1 ) == '-' ) then Priority = 1 else Priority = 0 endif elseif ( toke % tokenType == Monadic_Token ) then Priority = 5 else Priority = 0 endif endfunction Priority endmodule FEQParse","tags":"","loc":"sourcefile/feqparse.f90.html"},{"title":"FEQParse_TokenStack.f90 – FEQParse","text":"Contents Modules FEQParse_TokenStack Source Code FEQParse_TokenStack.f90 Source Code ! FEQParse.F03 ! ! Copyright 2020 Fluid Numerics LLC ! All rights reserved. ! ! Author : Joe Schoonover ( joe@fluidnumerics.com ) ! ! EquationParser defines a public class that can be used to parse and evaluate strings ! representative of equations. An equation, written in infix form, is converted to ! postfix form and evaluated using a postfix calculator. ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! module FEQParse_TokenStack use iso_fortran_env implicit none type Token character ( 48 ) :: tokenString integer :: tokenType integer :: tokenIndex contains procedure :: Copy endtype type TokenStack type ( Token ), allocatable :: tokens (:) integer :: top_index = 0 contains procedure :: Construct => Construct_TokenStack procedure :: Finalize => Finalize_TokenStack procedure :: Push => Push_TokenStack procedure :: Pop => Pop_TokenStack procedure :: IsEmpty => IsEmpty_TokenStack procedure :: TopToken endtype contains subroutine Construct_TokenStack ( stack , N ) class ( TokenStack ), intent ( out ) :: stack integer , intent ( in ) :: N allocate ( stack % tokens ( 1 : N )) stack % top_index = 0 endsubroutine Construct_TokenStack subroutine Finalize_TokenStack ( stack ) class ( TokenStack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_TokenStack subroutine Push_TokenStack ( stack , tok ) class ( TokenStack ), intent ( inout ) :: stack type ( Token ), intent ( in ) :: tok stack % top_index = stack % top_index + 1 stack % tokens ( stack % top_index )% tokenString = tok % tokenString stack % tokens ( stack % top_index )% tokenType = tok % tokenType stack % tokens ( stack % top_index )% tokenIndex = tok % tokenIndex endsubroutine Push_TokenStack subroutine Pop_TokenStack ( stack , tok ) class ( TokenStack ), intent ( inout ) :: stack type ( Token ), intent ( out ) :: tok if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok % tokenString = stack % tokens ( stack % top_index )% tokenString tok % tokenType = stack % tokens ( stack % top_index )% tokenType tok % tokenIndex = stack % tokens ( stack % top_index )% tokenIndex stack % top_index = stack % top_index - 1 endif endsubroutine Pop_TokenStack logical function IsEmpty_TokenStack ( stack ) class ( TokenStack ) :: stack IsEmpty_TokenStack = . false . if ( stack % top_index <= 0 ) then IsEmpty_TokenStack = . true . endif endfunction IsEmpty_TokenStack type ( Token ) function TopToken ( stack ) class ( TokenStack ) :: stack if ( stack % top_index > 0 ) then TopToken % tokenString = stack % tokens ( stack % top_index )% tokenString TopToken % tokenType = stack % tokens ( stack % top_index )% tokenType TopToken % tokenIndex = stack % tokens ( stack % top_index )% tokenIndex else TopToken % tokenString = '' endif endfunction TopToken function Copy ( this ) result ( that ) class ( Token ) :: this type ( Token ) :: that that % tokenString = this % tokenString that % tokenType = this % tokenType that % tokenIndex = this % tokenIndex endfunction Copy endmodule FEQParse_TokenStack","tags":"","loc":"sourcefile/feqparse_tokenstack.f90.html"},{"title":"FEQParse_Functions.f90 – FEQParse","text":"Contents Modules FEQParse_Functions Functions randomize_r32 randomize_r64 Source Code FEQParse_Functions.f90 Source Code ! FEQParse.F03 ! ! Copyright 2020 Fluid Numerics LLC ! All rights reserved. ! ! Author : Joe Schoonover ( joe@fluidnumerics.com ) ! ! EquationParser defines a public class that can be used to parse and evaluate strings ! representative of equations. An equation, written in infix form, is converted to ! postfix form and evaluated using a postfix calculator. ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! module FEQParse_Functions use iso_fortran_env implicit none integer , public :: nFunctions = 17 integer , protected , public :: maxFunctionLength = 0 integer , parameter :: maxFunctions = 100 logical :: isInitialized = . false . enum , bind ( c ) enumerator :: cos_function = 1 enumerator :: cosh_function = 2 enumerator :: sin_function = 3 enumerator :: sinh_function = 4 enumerator :: tan_function = 5 enumerator :: tanh_function = 6 enumerator :: sqrt_function = 7 enumerator :: abs_function = 8 enumerator :: exp_function = 9 enumerator :: ln_function = 10 enumerator :: log_function = 11 enumerator :: log10_function = 12 enumerator :: acos_function = 13 enumerator :: asin_function = 14 enumerator :: atan_function = 15 enumerator :: sech_function = 16 enumerator :: rand_function = 17 endenum private public :: InitializeFunctions , & AddFunction interface pure real ( real32 ) function f32 ( x ) import real ( real32 ), intent ( in ) :: x endfunction endinterface interface pure real ( real64 ) function f64 ( x ) import real ( real64 ), intent ( in ) :: x endfunction endinterface type Tuple character (:), allocatable :: item1 character (:), allocatable :: item2 contains final :: Tuple_Finalize endtype type , public :: FEQParse_Function integer :: len character (:), allocatable :: str character (:), allocatable :: caps procedure ( f32 ), public , nopass , pointer :: ptr32 => null () procedure ( f64 ), public , nopass , pointer :: ptr64 => null () contains procedure , private , pass ( lhs ) :: character_array_assign_function procedure , private , pass ( lhs ) :: character_assign_function generic :: assignment ( = ) => character_assign_function , character_array_assign_function procedure , private , pass ( lhs ) :: function_eq_character procedure , private , pass ( rhs ) :: character_eq_function generic :: operator ( == ) => function_eq_character , character_eq_function procedure , private , pass ( lhs ) :: function_neq_character procedure , private , pass ( rhs ) :: character_neq_function generic :: operator ( /= ) => function_neq_character , character_neq_function procedure , private , pass ( this ) :: invoke32 procedure , private , pass ( this ) :: invoke64 generic :: invoke => invoke32 , invoke64 final :: Function_Finalize endtype FEQParse_Function type ( FEQParse_Function ), public :: Functions ( maxFunctions ) interface pure real ( real32 ) function randomize_r32 () import endfunction endinterface interface pure real ( real64 ) function randomize_r64 () import endfunction endinterface interface AddFunction module procedure :: AddFunction32 module procedure :: AddFunction64 endinterface interface Tuple module procedure Tuple_new endinterface contains type ( Tuple ) function Tuple_new ( item1 , item2 ) result ( t ) character ( * ), intent ( in ) :: item1 character ( * ), intent ( in ) :: item2 t % item1 = item1 t % item2 = item2 endfunction subroutine Tuple_Finalize ( this ) type ( Tuple ), intent ( inout ) :: this if ( allocated ( this % item1 )) deallocate ( this % item1 ) if ( allocated ( this % item2 )) deallocate ( this % item2 ) endsubroutine subroutine Function_Finalize ( this ) type ( FEQParse_Function ), intent ( inout ) :: this if ( allocated ( this % str )) deallocate ( this % str ) if ( allocated ( this % caps )) deallocate ( this % caps ) if ( associated ( this % ptr32 )) nullify ( this % ptr32 ) if ( associated ( this % ptr64 )) nullify ( this % ptr64 ) endsubroutine subroutine character_array_assign_function ( lhs , rhs ) class ( FEQParse_Function ), intent ( inout ) :: lhs !! Left hand side. class ( Tuple ), intent ( in ) :: rhs !! Right hand side. lhs % str = rhs % item1 lhs % len = len ( rhs % item1 ) lhs % caps = rhs % item2 maxFunctionLength = max ( maxFunctionLength , lhs % len ) endsubroutine subroutine character_assign_function ( lhs , rhs ) class ( FEQParse_Function ), intent ( inout ) :: lhs !! Left hand side. character ( len =* ), intent ( in ) :: rhs !! Right hand side. lhs % str = rhs lhs % len = len ( rhs ) lhs % caps = ToUpperCase ( rhs ) maxFunctionLength = max ( maxFunctionLength , lhs % len ) endsubroutine elemental function function_eq_character ( lhs , rhs ) result ( ok ) class ( FEQParse_Function ), intent ( in ) :: lhs !! Left hand side. character ( len =* ), intent ( in ) :: rhs !! Right hand side. logical :: ok ok = lhs % str == rhs . or . lhs % caps == rhs endfunction elemental function character_eq_function ( lhs , rhs ) result ( ok ) character ( len =* ), intent ( in ) :: lhs class ( FEQParse_Function ), intent ( in ) :: rhs logical :: ok ok = lhs == rhs % str . or . lhs == rhs % caps endfunction elemental function function_neq_character ( lhs , rhs ) result ( ok ) class ( FEQParse_Function ), intent ( in ) :: lhs !! Left hand side. character ( len =* ), intent ( in ) :: rhs !! Right hand side. logical :: ok ok = lhs % str /= rhs . or . lhs % caps /= rhs endfunction elemental function character_neq_function ( lhs , rhs ) result ( ok ) character ( len =* ), intent ( in ) :: lhs class ( FEQParse_Function ), intent ( in ) :: rhs logical :: ok ok = lhs /= rhs % str . or . lhs /= rhs % caps endfunction subroutine InitializeFunctions () if ( isInitialized . eqv . . true .) return Functions ( cos_function ) = Tuple ( \"cos\" , \"COS\" ) Functions ( cos_function )% ptr32 => cos32 Functions ( cos_function )% ptr64 => cos64 Functions ( cosh_function ) = Tuple ( \"cosh\" , \"COSH\" ) Functions ( cosh_function )% ptr32 => cosh32 Functions ( cosh_function )% ptr64 => cosh64 Functions ( sin_function ) = Tuple ( \"sin\" , \"SIN\" ) Functions ( sin_function )% ptr32 => sin32 Functions ( sin_function )% ptr64 => sin64 Functions ( sinh_function ) = Tuple ( \"sinh\" , \"SINH\" ) Functions ( sinh_function )% ptr32 => sinh32 Functions ( sinh_function )% ptr64 => sinh64 Functions ( tan_function ) = Tuple ( \"tan\" , \"TAN\" ) Functions ( tan_function )% ptr32 => tan32 Functions ( tan_function )% ptr64 => tan64 Functions ( tanh_function ) = Tuple ( \"tanh\" , \"TANH\" ) Functions ( tanh_function )% ptr32 => tanh32 Functions ( tanh_function )% ptr64 => tanh64 Functions ( sqrt_function ) = Tuple ( \"sqrt\" , \"SQRT\" ) Functions ( sqrt_function )% ptr32 => sqrt32 Functions ( sqrt_function )% ptr64 => sqrt64 Functions ( abs_function ) = Tuple ( \"abs\" , \"ABS\" ) Functions ( abs_function )% ptr32 => abs32 Functions ( abs_function )% ptr64 => abs64 Functions ( exp_function ) = Tuple ( \"exp\" , \"EXP\" ) Functions ( exp_function )% ptr32 => exp32 Functions ( exp_function )% ptr64 => exp64 Functions ( ln_function ) = Tuple ( \"ln\" , \"LN\" ) Functions ( ln_function )% ptr32 => log32 Functions ( ln_function )% ptr64 => log64 Functions ( log_function ) = Tuple ( \"log\" , \"LOG\" ) Functions ( log_function )% ptr32 => log32 Functions ( log_function )% ptr64 => log64 Functions ( log10_function ) = Tuple ( \"log10\" , \"LOG10\" ) Functions ( log10_function )% ptr32 => log1032 Functions ( log10_function )% ptr64 => log1064 Functions ( acos_function ) = Tuple ( \"acos\" , \"ACOS\" ) Functions ( acos_function )% ptr32 => acos32 Functions ( acos_function )% ptr64 => acos64 Functions ( asin_function ) = Tuple ( \"asin\" , \"ASIN\" ) Functions ( asin_function )% ptr32 => asin32 Functions ( asin_function )% ptr64 => asin64 Functions ( atan_function ) = Tuple ( \"atan\" , \"ATAN\" ) Functions ( atan_function )% ptr32 => atan32 Functions ( atan_function )% ptr64 => atan64 Functions ( sech_function ) = Tuple ( \"sech\" , \"SECH\" ) Functions ( sech_function )% ptr32 => sech32 Functions ( sech_function )% ptr64 => sech64 Functions ( rand_function ) = Tuple ( \"rand\" , \"RAND\" ) Functions ( rand_function )% ptr32 => rand32 Functions ( rand_function )% ptr64 => rand64 isInitialized = . true . endsubroutine InitializeFunctions subroutine AddFunction32 ( name , f_32 ) character ( * ), intent ( in ) :: name procedure ( f32 ) :: f_32 !private type ( FEQParse_Function ) :: func call InitializeFunctions () func = name func % ptr32 => f_32 func % ptr64 => null () if ( nFunctions < maxFunctions ) then Functions ( nFunctions + 1 ) = func nFunctions = nFunctions + 1 else stop 'Argument out of range' endif endsubroutine subroutine AddFunction64 ( name , f_64 ) character ( * ), intent ( in ) :: name procedure ( f64 ) :: f_64 !private type ( FEQParse_Function ) :: func call InitializeFunctions () func = name func % ptr32 => null () func % ptr64 => f_64 if ( nFunctions < maxFunctions ) then Functions ( nFunctions + 1 ) = func nFunctions = nFunctions + 1 else stop 'Argument out of range' endif endsubroutine elemental real ( real32 ) function invoke32 ( this , x ) result ( fx ) class ( FEQParse_Function ), intent ( in ) :: this real ( real32 ), intent ( in ) :: x fx = this % ptr32 ( x ) endfunction elemental real ( real64 ) function invoke64 ( this , x ) result ( fx ) class ( FEQParse_Function ), intent ( in ) :: this real ( real64 ), intent ( in ) :: x fx = this % ptr64 ( x ) endfunction pure real ( real32 ) function cos32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = cos ( x ) endfunction pure real ( real64 ) function cos64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = cos ( x ) endfunction pure real ( real32 ) function cosh32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = cosh ( x ) endfunction pure real ( real64 ) function cosh64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = cosh ( x ) endfunction pure real ( real32 ) function sin32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = sin ( x ) endfunction pure real ( real64 ) function sin64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = sin ( x ) endfunction pure real ( real32 ) function sinh32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = sinh ( x ) endfunction pure real ( real64 ) function sinh64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = sinh ( x ) endfunction pure real ( real32 ) function tan32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = tan ( x ) endfunction pure real ( real64 ) function tan64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = tan ( x ) endfunction pure real ( real32 ) function tanh32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = tanh ( x ) endfunction pure real ( real64 ) function tanh64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = tanh ( x ) endfunction pure real ( real32 ) function sqrt32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = sqrt ( x ) endfunction pure real ( real64 ) function sqrt64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = sqrt ( x ) endfunction pure real ( real32 ) function abs32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = abs ( x ) endfunction pure real ( real64 ) function abs64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = abs ( x ) endfunction pure real ( real32 ) function exp32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = exp ( x ) endfunction pure real ( real64 ) function exp64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = exp ( x ) endfunction pure real ( real32 ) function log32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = log ( x ) endfunction pure real ( real64 ) function log64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = log ( x ) endfunction pure real ( real32 ) function log1032 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = log10 ( x ) endfunction pure real ( real64 ) function log1064 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = log10 ( x ) endfunction pure real ( real32 ) function acos32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = acos ( x ) endfunction pure real ( real64 ) function acos64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = acos ( x ) endfunction pure real ( real32 ) function asin32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = asin ( x ) endfunction pure real ( real64 ) function asin64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = asin ( x ) endfunction pure real ( real32 ) function atan32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = atan ( x ) endfunction pure real ( real64 ) function atan64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = atan ( x ) endfunction pure real ( real32 ) function sech32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x fx = 2.0_real32 / ( exp ( x ) + exp ( - x )) endfunction pure real ( real64 ) function sech64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x fx = 2.0_real64 / ( exp ( x ) + exp ( - x )) endfunction pure real ( real32 ) function rand32 ( x ) result ( fx ) real ( real32 ), intent ( in ) :: x !private real ( real32 ) :: r associate ( r => randomize_r32 ()) fx = r * x endassociate endfunction pure real ( real64 ) function rand64 ( x ) result ( fx ) real ( real64 ), intent ( in ) :: x !private real ( real64 ) :: r associate ( r => randomize_r64 ()) fx = r * x endassociate endfunction pure function ToUpperCase ( str ) result ( res ) character ( * ), intent ( in ) :: str character ( len ( str )) :: res integer :: i do i = 1 , len ( str ) select case ( str ( i : i )) case ( 'a' : 'z' ) res ( i : i ) = achar ( iachar ( str ( i : i )) - 32 ) case default res ( i : i ) = str ( i : i ) endselect enddo endfunction ToUpperCase endmodule FEQParse_Functions real ( real32 ) function randomize_r32 () use , intrinsic :: iso_fortran_env , only : real32 real ( real32 ) :: r call random_number ( r ) randomize_r32 = r endfunction real ( real64 ) function randomize_r64 () use , intrinsic :: iso_fortran_env , only : real64 real ( real64 ) :: r call random_number ( r ) randomize_r64 = r endfunction","tags":"","loc":"sourcefile/feqparse_functions.f90.html"},{"title":"FEQParse_FloatStacks.f90 – FEQParse","text":"Contents Modules FEQParse_FloatStacks Source Code FEQParse_FloatStacks.f90 Source Code ! FEQParse.F03 ! ! Copyright 2020 Fluid Numerics LLC ! All rights reserved. ! ! Author : Joe Schoonover ( joe@fluidnumerics.com ) ! ! EquationParser defines a public class that can be used to parse and evaluate strings ! representative of equations. An equation, written in infix form, is converted to ! postfix form and evaluated using a postfix calculator. ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! module FEQParse_FloatStacks use iso_fortran_env implicit none type feqparse_floatstack integer :: top_index endtype feqparse_floatstack type , extends ( feqparse_floatstack ) :: sfp32Stack real ( real32 ), allocatable :: tokens (:) contains procedure :: Construct => Construct_sfp32Stack final :: Finalize_sfp32Stack procedure :: Push => Push_sfp32Stack procedure :: Pop => Pop_sfp32Stack endtype sfp32Stack type , extends ( feqparse_floatstack ) :: sfp64Stack real ( real64 ), allocatable :: tokens (:) contains procedure :: Construct => Construct_sfp64Stack final :: Finalize_sfp64Stack procedure :: Push => Push_sfp64Stack procedure :: Pop => Pop_sfp64Stack endtype sfp64Stack type , extends ( feqparse_floatstack ) :: r1fp32Stack real ( real32 ), allocatable :: tokens (:,:) contains procedure :: Construct => Construct_r1fp32Stack final :: Finalize_r1fp32Stack procedure :: Push => Push_r1fp32Stack procedure :: Pop => Pop_r1fp32Stack endtype r1fp32Stack type , extends ( feqparse_floatstack ) :: r1fp64Stack real ( real64 ), allocatable :: tokens (:,:) contains procedure :: Construct => Construct_r1fp64Stack final :: Finalize_r1fp64Stack procedure :: Push => Push_r1fp64Stack procedure :: Pop => Pop_r1fp64Stack endtype r1fp64Stack type , extends ( feqparse_floatstack ) :: r2fp32Stack real ( real32 ), allocatable :: tokens (:,:,:) contains procedure :: Construct => Construct_r2fp32Stack final :: Finalize_r2fp32Stack procedure :: Push => Push_r2fp32Stack procedure :: Pop => Pop_r2fp32Stack endtype r2fp32Stack type , extends ( feqparse_floatstack ) :: r2fp64Stack real ( real64 ), allocatable :: tokens (:,:,:) contains procedure :: Construct => Construct_r2fp64Stack final :: Finalize_r2fp64Stack procedure :: Push => Push_r2fp64Stack procedure :: Pop => Pop_r2fp64Stack endtype r2fp64Stack type , extends ( feqparse_floatstack ) :: r3fp32Stack real ( real32 ), allocatable :: tokens (:,:,:,:) contains procedure :: Construct => Construct_r3fp32Stack final :: Finalize_r3fp32Stack procedure :: Push => Push_r3fp32Stack procedure :: Pop => Pop_r3fp32Stack endtype r3fp32Stack type , extends ( feqparse_floatstack ) :: r3fp64Stack real ( real64 ), allocatable :: tokens (:,:,:,:) contains procedure :: Construct => Construct_r3fp64Stack final :: Finalize_r3fp64Stack procedure :: Push => Push_r3fp64Stack procedure :: Pop => Pop_r3fp64Stack endtype r3fp64Stack type , extends ( feqparse_floatstack ) :: r4fp32Stack real ( real32 ), allocatable :: tokens (:,:,:,:,:) contains procedure :: Construct => Construct_r4fp32Stack final :: Finalize_r4fp32Stack procedure :: Push => Push_r4fp32Stack procedure :: Pop => Pop_r4fp32Stack endtype r4fp32Stack type , extends ( feqparse_floatstack ) :: r4fp64Stack real ( real64 ), allocatable :: tokens (:,:,:,:,:) contains procedure :: Construct => Construct_r4fp64Stack final :: Finalize_r4fp64Stack procedure :: Push => Push_r4fp64Stack procedure :: Pop => Pop_r4fp64Stack endtype r4fp64Stack contains subroutine Construct_sfp32Stack ( stack , N ) class ( sfp32Stack ), intent ( out ) :: stack integer , intent ( in ) :: N allocate ( stack % tokens ( 1 : N )) stack % top_index = 0 endsubroutine Construct_sfp32Stack subroutine Finalize_sfp32Stack ( stack ) type ( sfp32Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_sfp32Stack subroutine Push_sfp32Stack ( stack , tok ) class ( sfp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( in ) :: tok stack % top_index = stack % top_index + 1 stack % tokens ( stack % top_index ) = tok endsubroutine Push_sfp32Stack subroutine Pop_sfp32Stack ( stack , tok ) class ( sfp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( out ) :: tok if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok = stack % tokens ( stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_sfp32Stack subroutine Construct_sfp64Stack ( stack , N ) class ( sfp64Stack ), intent ( out ) :: stack integer , intent ( in ) :: N allocate ( stack % tokens ( 1 : N )) stack % top_index = 0 endsubroutine Construct_sfp64Stack subroutine Finalize_sfp64Stack ( stack ) type ( sfp64Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_sfp64Stack subroutine Push_sfp64Stack ( stack , tok ) class ( sfp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( in ) :: tok stack % top_index = stack % top_index + 1 stack % tokens ( stack % top_index ) = tok endsubroutine Push_sfp64Stack subroutine Pop_sfp64Stack ( stack , tok ) class ( sfp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( out ) :: tok if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok = stack % tokens ( stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_sfp64Stack ! >> Rank 1 fp32, fp64 << ! subroutine Construct_r1fp32Stack ( stack , N , mold ) implicit none class ( r1fp32Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real32 ), intent ( in ) :: mold (:) ! local integer :: l ( 1 ) integer :: u ( 1 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), 1 : N )) stack % top_index = 0 endsubroutine Construct_r1fp32Stack subroutine Finalize_r1fp32Stack ( stack ) type ( r1fp32Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r1fp32Stack subroutine Push_r1fp32Stack ( stack , tok ) class ( r1fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( in ) :: tok (:) stack % top_index = stack % top_index + 1 stack % tokens (:, stack % top_index ) = tok (:) endsubroutine Push_r1fp32Stack subroutine Pop_r1fp32Stack ( stack , tok ) class ( r1fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( out ) :: tok (:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:) = stack % tokens (:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r1fp32Stack subroutine Construct_r1fp64Stack ( stack , N , mold ) class ( r1fp64Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real64 ), intent ( in ) :: mold (:) ! local integer :: l ( 1 ) integer :: u ( 1 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), 1 : N )) stack % top_index = 0 endsubroutine Construct_r1fp64Stack subroutine Finalize_r1fp64Stack ( stack ) type ( r1fp64Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r1fp64Stack subroutine Push_r1fp64Stack ( stack , tok ) class ( r1fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( in ) :: tok (:) stack % top_index = stack % top_index + 1 stack % tokens (:, stack % top_index ) = tok (:) endsubroutine Push_r1fp64Stack subroutine Pop_r1fp64Stack ( stack , tok ) class ( r1fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( out ) :: tok (:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:) = stack % tokens (:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r1fp64Stack subroutine Construct_r2fp32Stack ( stack , N , mold ) class ( r2fp32Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real32 ), intent ( in ) :: mold (:,:) ! local integer :: l ( 1 : 2 ), u ( 1 : 2 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r2fp32Stack subroutine Finalize_r2fp32Stack ( stack ) type ( r2fp32Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r2fp32Stack subroutine Push_r2fp32Stack ( stack , tok ) class ( r2fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( in ) :: tok (:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:, stack % top_index ) = tok (:,:) endsubroutine Push_r2fp32Stack subroutine Pop_r2fp32Stack ( stack , tok ) class ( r2fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( out ) :: tok (:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:) = stack % tokens (:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r2fp32Stack subroutine Construct_r2fp64Stack ( stack , N , mold ) class ( r2fp64Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real64 ), intent ( in ) :: mold (:,:) ! local integer :: l ( 1 : 2 ), u ( 1 : 2 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r2fp64Stack subroutine Finalize_r2fp64Stack ( stack ) type ( r2fp64Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r2fp64Stack subroutine Push_r2fp64Stack ( stack , tok ) class ( r2fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( in ) :: tok (:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:, stack % top_index ) = tok (:,:) endsubroutine Push_r2fp64Stack subroutine Pop_r2fp64Stack ( stack , tok ) class ( r2fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( out ) :: tok (:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:) = stack % tokens (:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r2fp64Stack subroutine Construct_r3fp32Stack ( stack , N , mold ) class ( r3fp32Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real32 ), intent ( in ) :: mold (:,:,:) ! local integer :: l ( 1 : 3 ), u ( 1 : 3 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & l ( 3 ): u ( 3 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r3fp32Stack subroutine Finalize_r3fp32Stack ( stack ) type ( r3fp32Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r3fp32Stack subroutine Push_r3fp32Stack ( stack , tok ) class ( r3fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( in ) :: tok (:,:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:,:, stack % top_index ) = tok (:,:,:) endsubroutine Push_r3fp32Stack subroutine Pop_r3fp32Stack ( stack , tok ) class ( r3fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( out ) :: tok (:,:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:,:) = stack % tokens (:,:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r3fp32Stack subroutine Construct_r3fp64Stack ( stack , N , mold ) class ( r3fp64Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real64 ), intent ( in ) :: mold (:,:,:) ! local integer :: l ( 1 : 3 ), u ( 1 : 3 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & l ( 3 ): u ( 3 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r3fp64Stack subroutine Finalize_r3fp64Stack ( stack ) type ( r3fp64Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r3fp64Stack subroutine Push_r3fp64Stack ( stack , tok ) class ( r3fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( in ) :: tok (:,:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:,:, stack % top_index ) = tok (:,:,:) endsubroutine Push_r3fp64Stack subroutine Pop_r3fp64Stack ( stack , tok ) class ( r3fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( out ) :: tok (:,:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:,:) = stack % tokens (:,:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r3fp64Stack subroutine Construct_r4fp32Stack ( stack , N , mold ) class ( r4fp32Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real32 ), intent ( in ) :: mold (:,:,:,:) ! local integer :: l ( 1 : 4 ), u ( 1 : 4 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & l ( 3 ): u ( 3 ), & l ( 4 ): u ( 4 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r4fp32Stack subroutine Finalize_r4fp32Stack ( stack ) type ( r4fp32Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r4fp32Stack subroutine Push_r4fp32Stack ( stack , tok ) class ( r4fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( in ) :: tok (:,:,:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:,:,:, stack % top_index ) = tok (:,:,:,:) endsubroutine Push_r4fp32Stack subroutine Pop_r4fp32Stack ( stack , tok ) class ( r4fp32Stack ), intent ( inout ) :: stack real ( real32 ), intent ( out ) :: tok (:,:,:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:,:,:) = stack % tokens (:,:,:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r4fp32Stack subroutine Construct_r4fp64Stack ( stack , N , mold ) class ( r4fp64Stack ), intent ( out ) :: stack integer , intent ( in ) :: N real ( real64 ), intent ( in ) :: mold (:,:,:,:) ! local integer :: l ( 1 : 4 ), u ( 1 : 4 ) l = lbound ( mold ) u = ubound ( mold ) allocate ( stack % tokens ( l ( 1 ): u ( 1 ), & l ( 2 ): u ( 2 ), & l ( 3 ): u ( 3 ), & l ( 4 ): u ( 4 ), & 1 : N )) stack % top_index = 0 endsubroutine Construct_r4fp64Stack subroutine Finalize_r4fp64Stack ( stack ) type ( r4fp64Stack ), intent ( inout ) :: stack if ( allocated ( stack % tokens )) deallocate ( stack % tokens ) endsubroutine Finalize_r4fp64Stack subroutine Push_r4fp64Stack ( stack , tok ) class ( r4fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( in ) :: tok (:,:,:,:) stack % top_index = stack % top_index + 1 stack % tokens (:,:,:,:, stack % top_index ) = tok (:,:,:,:) endsubroutine Push_r4fp64Stack subroutine Pop_r4fp64Stack ( stack , tok ) class ( r4fp64Stack ), intent ( inout ) :: stack real ( real64 ), intent ( out ) :: tok (:,:,:,:) if ( stack % top_index <= 0 ) then print * , \"Attempt to pop from empty token stack\" else tok (:,:,:,:) = stack % tokens (:,:,:,:, stack % top_index ) stack % top_index = stack % top_index - 1 endif endsubroutine Pop_r4fp64Stack endmodule FEQParse_FloatStacks","tags":"","loc":"sourcefile/feqparse_floatstacks.f90.html"}]}